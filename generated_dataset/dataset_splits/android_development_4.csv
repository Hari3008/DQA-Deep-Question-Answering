,Question,Answer,Context
0,Explain why developer interest in Android devices has exploded as handset sales have continued to grow,"A host of Android handsets are now available to tempt consumers, including phones with QVGA screens and powerful WVGA devices like the Motorola Droid and the Google Nexus One. The real win though, is for developers. With much existing mobile development built on proprietary operating systems that restrict the development and deployment of third-party applications, Android offers an open alternative. Without artificial barriers, Android developers are free to write applications that take full advantage of increasingly powerful mobile hardware and distribute them in an open market. Hence,developer interest in Android devices has exploded as handset sales have continued to grow.","Special thanks go out to the Android developer community. Your hard work and exciting applica- tions have helped make Android a great success. INTRODUCTION xxvii CHAPTER 1: HELLO, ANDROID 1 A Little Background 2 The Not-So-Distant Past 2 The Future 3 What It Isn’t 3 Android: An Open Platform for Mobile Development 4 Native Android Applications 5 Android SDK Features 6 Access to Hardware, Including Camera, GPS, and Accelerometer 6 Native Google Maps, Geocoding, and Location-Based Services 7 Background Services 7 SQLite Database for Data Storage and Retrieval 7 Shared Data and Interapplication Communication 7 Using Widgets, Live Folders, and Live Wallpaper to Enhance the Home Screen 8 Extensive Media Support and 2D/3D Graphics 8 Optimized Memory and Process Management 8 Introducing the Open Handset Alliance 9 What Does Android Run On? 9 Why Develop for Mobile? 9 Why Develop for Android? 10 What Has and Will Continue to Drive Android Adoption? 10 What Does It Have That Others Don’t? 11 Changing the Mobile Development Landscape 11 Introducing the Development Framework 12 What Comes in the Box 12 Understanding the Android Software Stack 13 The Dalvik Virtual Machine 14 Android Application Architecture 15 Android Libraries 16 Summary 16 CONTENTS CHAPTER 2: GETTING STARTED 17 Developing for Android 18 What You Need to Begin 18 Downloading and Installing the SDK 18 Developing with Eclipse 19 Using the Eclipse Plug-In 20 Creating Your First Android Application 23 Starting a New Android Project 23 Creating a Launch Configuration 24 Running and Debugging Your Android Applications 26 Understanding Hello World 26 Types of Android Applications 29 Foreground Applications 29 Background Services and Intent Receivers 29 Intermittent Applications 30 Widgets 30 Developing for Mobile Devices 30 Hardware-Imposed Design Considerations 30 Be Efficient 31 Expect Limited Capacity 31 Design for Small Screens 32 Expect Low Speeds, High Latency 32 At What Cost? 33 Considering the Users’ Environment 34 Developing for Android 35 Being Fast and Efficient 35 Being Responsive 36 Developing Secure Applications 37 Ensuring a Seamless User Experience 37 To-Do List Example 38 Android Development Tools 43 The Android Virtual Device and SDK Manager 44 Android Virtual Devices 44 SDK Manager 45 The Android Emulator 46 Dalvik Debug Monitor Service (DDMS) 47 The Android Debug Bridge (ADB) 47 Summary 48 xiv CONTENTS CHAPTER 3: CREATING APPLICATIONS AND ACTIVITIES 49 What Makes an Android Application? 50 Introducing the Application Manifest 51 Using the Manifest Editor 56 The Android Application Life Cycle 57 Understanding Application Priority and Process States 58 Externalizing Resources 59 Creating Resources 60 Creating Simple Values 60 Styles and Themes 62 Drawables 63 Layouts 63 Animations 64 Menus 66 Using Resources 67 Using Resources in Code 67 Referencing Resources within Resources 68 Using System Resources 69 Referring to Styles in the Current Theme 70 To-Do List Resources Example 70 Creating Resources for Different Languages and Hardware 71 Runtime Configuration Changes 72 Introducing the Android Application Class 74 Extending and Using the Application Class 74 Overriding the Application Life Cycle Events 75 A Closer Look at Android Activities 76 Creating an Activity 77 The Activity Life Cycle 78 Activity Stacks 78 Activity States 79 Monitoring State Changes 80 Understanding Activity Lifetimes 82 Android Activity Classes 84 Summary 84 CHAPTER 4: CREATING USER INTERFACES 85 Fundamental Android UI Design 86 Introducing Views 86 xv CONTENTS Creating Activity User Interfaces with Views 87 The Android Widget Toolbox 88 Introducing Layouts 89 Using Layouts 89 Optimizing Layouts 91 Creating New Views 91 Modifying Existing Views 92 Customizing Your To-Do List 93 Creating Compound Controls 96 Creating Custom Views 99 Creating a New Visual Interface 99 Handling User Interaction Events 104 Creating a Compass View Example 105 Using Custom Controls 110 Drawable Resources 111 Shapes, Colors, and Gradients 111 Color Drawable 111 Shape Drawable 111 Gradient Drawable 113 Composite Drawables 114 Transformative Drawables 114 Layer Drawable 116 State List Drawables 116 Level List Drawables 116 NinePatch Drawable 117 Resolution and Density Independence 117 The Resource Framework and Resolution Independence 118 Resource Qualifiers for Screen Size and Pixel Density 118 Specifying Supported Screen Sizes 119 Best Practices for Resolution Independence 119 Relative Layouts and Density-Independent Pixels 120 Using Scalable Graphics Assets 120 Provide Optimized Resources for Different Screens 121 Testing, Testing, Testing 121 Emulator Skins 122 Testing for Custom Resolutions and Screen Sizes 122 Creating and Using Menus 123 Introducing the Android Menu System 123 Defining an Activity Menu 124 Menu Item Options 126 xvi CONTENTS Dynamically Updating Menu Items 127 Handling Menu Selections 127 Submenus and Context Menus 128 Creating Submenus 128 Using Context Menus 128 Defining Menus in XML 130 To-Do List Example Continued 131 Summary 136 CHAPTER 5: INTENTS, BROADCAST RECEIVERS, ADAPTERS, AND THE INTERNET 137 Introducing Intents 138 Using Intents to Launch Activities 138 Explicitly Starting New Activities 139 Implicit Intents and Late Runtime Binding 139 Returning Results from Activities 140 Native Android Actions 143 Using Intent Filters to Service Implicit Intents 144 How Android Resolves Intent Filters 146 Finding and Using the Launch Intent Within an Activity 147 Passing on Responsibility 147 Select a Contact Example 148 Using Intent Filters for Plug-Ins and Extensibility 152 Supplying Anonymous Actions to Applications 153 Incorporating Anonymous Actions in Your Activity’s Menu 154 Introducing Linkify 155 The Native Linkify Link Types 155 Creating Custom Link Strings 156 Using the Match Filter 157 Using the Transform Filter 157 Using Intents to Broadcast Events 157 Broadcasting Events with Intents 158 Listening for Broadcasts with Broadcast Receivers 158 Broadcasting Sticky and Ordered Intents 161 Native Android Broadcast Actions 161 Introducing Pending Intents 162 Introducing Adapters 163 Introducing Some Native Adapters 163 Customizing the Array Adapter 163 Using Adapters for Data Binding 164 xvii CONTENTS Customizing the To-Do List Array Adapter 165 Using the Simple Cursor Adapter 169 Using Internet Resources 170 Connecting to an Internet Resource 170 Using Internet Resources 171 Introducing Dialogs 172 Introducing the Dialog Classes 172 The Alert Dialog Class 173 Specialist Input Dialogs 174 Using Activities as Dialogs 174 Managing and Displaying Dialogs 175 Creating an Earthquake Viewer 176 Summary 184 CHAPTER 6: FILES, SAVING STATE, AND PREFERENCES 187 Saving Simple Application Data 188 Creating and Saving Preferences 188 Retrieving Shared Preferences 189 Creating a Settings Activity for the Earthquake Viewer 189 Introducing the Preference Activity and Preferences Framework 197 Defining a Preference Screen Layout in XML 198 Native Preference Controls 199 Using Intents to Import System Preference Screens 200 Introducing the Preference Activity 200 Finding and Using Preference Screen Shared Preferences 201 Introducing Shared Preference Change Listeners 201 Creating a Standard Preference Activity for the Earthquake Viewer 202 Saving Activity State 203 Saving and Restoring Instance State 203 Saving the To-Do List Activity State 205 Saving and Loading Files 207 Including Static Files as Resources 207 File Management Tools 208 Summary 208 CHAPTER 7: DATABASES AND CONTENT PROVIDERS 209 Introducing Android Databases 209 Introducing SQLite Databases 210 Introducing Content Providers 210 xviii CONTENTS Introducing SQLite 210 Cursors and Content Values 211 Working with SQLite Databases 211 Introducing the SQLiteOpenHelper 214 Opening and Creating Databases without SQLiteHelper 215 Android Database Design Considerations 215 Querying a Database 215 Extracting Results from a Cursor 216 Adding, Updating, and Removing Rows 217 Inserting New Rows 217 Updating a Row 218 Deleting Rows 218 Saving Your To-Do List 218 Creating a New Content Provider 224 Exposing Access to the Data Source 225 Registering Your Provider 227 Using Content Providers 227 Introducing Content Resolvers 227 Querying for Content 228 Adding, Updating, and Deleting Content 228 Inserts 228 Deletes 229 Updates 229 Accessing Files in Content Providers 230 Creating and Using an Earthquake Content Provider 230 Creating the Content Provider 230 Using the Provider 236 Native Android Content Providers 238 Using the Media Store Provider 239 Using the Contacts Provider 240 Introducing the Contacts Contract Content Provider 240 Reading Contact Details 240 Modifying and Augmenting Contact Details 243 Summary 244 CHAPTER 8: MAPS, GEOCODING, AND LOCATION-BASED SERVICES 245 Using Location-Based Services 246 Configuring the Emulator to Test Location-Based Services 246 Updating Locations in Emulator Location Providers 246 xix CONTENTS Selecting a Location Provider 247 Finding the Available Providers 248 Finding Location Providers Using Criteria 248 Finding Your Location 249 ‘Where Am I?’ Example 250 Tracking Movement 252 Updating Your Location in ‘Where Am I?’ 253 Using Proximity Alerts 255 Using the Geocoder 256 Reverse Geocoding 257 Forward Geocoding 258 Geocoding ‘Where Am I?’ 259 Creating Map-Based Activities 260 Introducing Map View and Map Activity 260 Getting Your Maps API Key 261 Getting Your Development/Debugging MD5 Fingerprint 261 Getting your Production/Release MD5 Fingerprint 262 Creating a Map-Based Activity 262 Configuring and Using Map Views 263 Using the Map Controller 264 Mapping ‘Where Am I?’ 265 Creating and Using Overlays 268 Creating New Overlays 268 Introducing Projections 269 Drawing on the Overlay Canvas 269 Handling Map Tap Events 270 Adding and Removing Overlays 271 Annotating ‘Where Am I?’ 271 Introducing My Location Overlay 275 Introducing Itemized Overlays and Overlay Items 275 Pinning Views to the Map and Map Positions 278 Mapping Earthquakes Example 279 Summary 284 CHAPTER 9: WORKING IN THE BACKGROUND 285 Introducing Services 286 Creating and Controlling Services 287 Creating a Service 287 Registering a Service in the Manifest 289 Self-Terminating a Service 289 xx CONTENTS Starting, Controlling, and Interacting with a Service 290 An Earthquake Monitoring Service Example 290 Binding Activities to Services 297 Prioritizing Background Services 299 Using Background Threads 300 Using AsyncTask to Run Asynchronous Tasks 301 Creating a New Asynchronous Task 301 Running an Asynchronous Task 302 Moving the Earthquake Service to a Background Thread Using AsyncTask 303 Manual Thread Creation and GUI Thread Synchronization 304 Creating a New Thread 304 Using the Handler for Performing GUI Operations 304 Let’s Make a Toast 306 Customizing Toasts 306 Using Toasts in Worker Threads 308 Introducing Notifications 309 Introducing the Notification Manager 310 Creating Notifications 310 Creating a Notification and Configuring the Status Bar Icon 310 Configuring the Extended Status Notification Display 311 Triggering Notifications 313 Adding Notifications and Toasts to the Earthquake Monitor 314 Advanced Notification Techniques 316 Using the Defaults 317 Making Sounds 317 Vibrating the Phone 317 Flashing the Lights 318 Ongoing and Insistent Notifications 319 Using Alarms 320 Setting Repeating Alarms 322 Using Repeating Alarms to Update Earthquakes 323 Summary 325 CHAPTER 10: INVADING THE PHONE-TOP 327 Introducing Home-Screen Widgets 328 Creating App Widgets 328 Creating the Widget Layout 329 Widget Design Guidelines 329 Supported Widget Views and Layouts 330 Defining Your Widget Settings 331 xxi CONTENTS Creating Your Widget Intent Receiver and Adding It to the Application Manifest 332 Introducing Remote Views and the App Widget Manager 333 Creating Remote Views and Using the App Widget Manager to Apply Them 333 Using a Remote View within the App Widget Provider’s onUpdate Handler 334 Using Remote Views to Modify UI 335 Making Your Widgets Interactive 335 Refreshing Your Widgets 337 Using the Minimum Update Rate 337 Listening for Intents 338 Using Alarms 339 Creating and Using a Widget Configuration Activity 340 Creating an Earthquake Widget 341 Introducing Live Folders 346 Creating Live Folders 346 Live Folder Content Providers 347 Live Folder Activity 348 Creating an Earthquake Live Folder 349 Adding Search to Your Applications and the Quick Search Box 351 Adding Search to Your Application 351 Creating a Search Activity 352 Responding to Search Queries from a Content Provider 353 Surfacing Search Results to the Quick Search Box 355 Adding Search to the Earthquake Example 355 Creating Live Wallpaper 358 Creating a Live Wallpaper Definition Resource 359 Creating a Wallpaper Service 359 Creating a Wallpaper Service Engine 360 Summary 361 CHAPTER 11: AUDIO, VIDEO, AND USING THE CAMERA 363 Playing Audio and Video 364 Introducing the Media Player 364 Preparing Audio for Playback 365 Packaging Audio as an Application Resource 365 Initializing Audio Content for Playback 365 Preparing for Video Playback 366 Playing Video Using the Video View 367 xxii CONTENTS Setting up a Surface for Video Playback 367 Initializing Video Content for Playback 369 Controlling Playback 370 Managing Media Playback Output 370 Recording Audio and Video 371 Using Intents to Record Video 371 Using the Media Recorder 372 Configuring and Controlling Video Recording 373 Previewing Video Recording 374 Using the Camera and Taking Pictures 375 Using Intents to Take Pictures 375 Controlling the Camera and Taking Pictures 377 Controlling and Monitoring Camera Settings and Image Options 377 Monitoring Auto Focus 379 Using the Camera Preview 379 Taking a Picture 381 Reading and Writing JPEG EXIF Image Details 381 Adding New Media to the Media Store 382 Using the Media Scanner 382 Inserting Media into the Media Store 383 Raw Audio Manipulation 384 Recording Sound with Audio Record 384 Playing Sound with Audio Track 385 Speech Recognition 386 Summary 388 CHAPTER 12: TELEPHONY AND SMS 389 Telephony 390 Launching the Dialer to Initiate Phone Calls 390 Replacing the Native Dialer 390 Accessing Phone and Network Properties and Status 392 Reading Phone Device Details 392 Reading Data Connection and Transfer State 392 Reading Network Details 393 Reading SIM Details 394 Monitoring Changes in Phone State, Phone Activity, and Data Connections 395 Monitoring Incoming Phone Calls 396 Tracking Cell Location Changes 396 Tracking Service Changes 397 Monitoring Data Connectivity and Activity 398 xxiii CONTENTS Introducing SMS and MMS 398 Using SMS and MMS in Your Application 399 Sending SMS and MMS from Your Application Using Intents and the Native Client 399 Sending SMS Messages Manually 400 Sending Text Messages 400 Tracking and Confirming SMS Message Delivery 401 Conforming to the Maximum SMS Message Size 402 Sending Data Messages 403 Listening for Incoming SMS Messages 403 Simulating Incoming SMS Messages in the Emulator 405 Handling Data SMS Messages 406 Emergency Responder SMS Example 406 Automating the Emergency Responder 415 Summary 423 CHAPTER 13: BLUETOOTH, NETWORKS, AND WI-FI 425 Using Bluetooth 425 Accessing the Local Bluetooth Device Adapter 426 Managing Bluetooth Properties and State 427 Being Discoverable and Remote Device Discovery 430 Managing Device Discoverability 430 Discovering Remote Devices 431 Bluetooth Communications 433 Opening a Bluetooth Server Socket Listener 434 Selecting Remote Bluetooth Devices for Communications 435 Opening a Client Bluetooth Socket Connection 437 Transmitting Data Using Bluetooth Sockets 438 Bluetooth Data Transfer Example 439 Managing Network Connectivity 448 Introducing the Connectivity Manager 448 Reading User Preferences for Background Data Transfer 449 Monitoring Network Details 450 Finding and Configuring Network Preferences and Controlling Hardware Radios 451 Monitoring Network Connectivity 451 Managing Your Wi-Fi 452 Monitoring Wi-Fi Connectivity 452 Monitoring Active Connection Details 453 Scanning for Hotspots 453 xxiv CONTENTS Managing Wi-Fi Configurations 454 Creating Wi-Fi Network Configurations 455 Summary 455 CHAPTER 14: SENSORS 457 Using Sensors and the Sensor Manager 458 Introducing Sensors 458 Supported Android Sensors 458 Finding Sensors 459 Using Sensors 459 Interpreting Sensor Values 461 Using the Compass, Accelerometer, and Orientation Sensors 462 Introducing Accelerometers 462 Detecting Acceleration Changes 463 Creating a G-Forceometer 464 Determining Your Orientation 467 Determining Orientation Using the Orientation Sensor 468 Calculating Orientation Using the Accelerometer and Magnetic Field Sensors 468 Remapping the Orientation Reference Frame 470 Creating a Compass and Artificial Horizon 470 Controlling Device Vibration 474 Summary 475 CHAPTER 15: ADVANCED ANDROID DEVELOPMENT 477 Paranoid Android 478 Linux Kernel Security 478 Introducing Permissions 478 Declaring and Enforcing Permissions 479 Enforcing Permissions for Broadcast Intents 480 Using Wake Locks 480 Introducing Android Text to Speech 481 Using AIDL to Support IPC for Services 483 Implementing an AIDL Interface 484 Passing Class Objects as Parcelables 484 Creating the AIDL Service Definition 486 Implementing and Exposing the IPC Interface 487 Using Internet Services 488 Building Rich User Interfaces 489 xxv CONTENTS Working with Animations 489 Introducing Tweened Animations 490 Creating Tweened Animations 490 Applying Tweened Animations 492 Using Animation Listeners 492 Animated Sliding User Interface Example 493 Animating Layouts and View Groups 498 Creating and Using Frame-by-Frame Animations 500 Advanced Canvas Drawing 501 What Can You Draw? 501 Getting the Most from Your Paint 502 Improving Paint Quality with Anti-Aliasing 507 Canvas Drawing Best Practice 507 Advanced Compass Face Example 508 Bringing Map Overlays to Life 516 Introducing the Surface View 517 When Should You Use a Surface View? 517 Creating a New Surface View 517 Creating 3D Controls with a Surface View 519 Creating Interactive Controls 520 Using the Touch Screen 520 Using the Device Keys, Buttons, and D-Pad 524 Using the On Key Listener 525 Using the Trackball 526 Summary 526 INDEX 529 xxvi INTRODUCTION Now is an exciting time for mobile developers. Mobile phones have never been more popular, and powerful smartphones are now a popular choice for consumers. Stylish and versatile phones packing hardware features like GPS, accelerometers, and touch screens, combined with fixed-rate, reasonably priced data plans provide an enticing platform upon which to create innovative mobile applications.A host of Android handsets are now available to tempt consumers, including phones with QVGA screens and powerful WVGA devices like the Motorola Droid and the Google Nexus One. The real win though, is for developers. With much existing mobile development built on proprietary operating systems that restrict the development and deployment of third-party applications, Android offers an open alternative. Without artificial barriers, Android developers are free to write applications that take full advantage of increasingly powerful mobile hardware and distribute them in an open market.As a result, developer interest in Android devices has exploded as handset sales have continued to grow.In 2009 and the early parts of 2010 more than 20 Android handsets have been released from OEMs including HTC, Motorola, LG, Samsung, and Sony Ericsson. Android devices are now available in over 26 countries on more than 32 carriers. In the United States, Android devices are available on all four major carriers: T-Mobile, Verizon, AT&T, and Sprint. Additionally, you can now buy the unlocked Google Nexus One handset directly from Google at http://www.google.com/phone."
1,Explain why you get the benefits of using Java while your appli- cations have the advantage of running on a virtual machine optimized for mobile devices,"Versions of the SDK, Java, and Eclipse are available for Windows, MacOS, and Linux, so you can explore Android from the comfort of whatever OS you favor. The SDK tools and emula- tor work on all three OS environments, and because Android applications are run on a virtual machine, there’s no advantage to developing from any particular operating system.Android code is written with Java syntax, and the core Android libraries include most of the features from the core Java APIs. Before they can be run, though, your projects must first be translated into Dalvik byte code. Hence,you get the benefits of using Java while your appli- cations have the advantage of running on a virtual machine optimized for mobile devices.","All you need to start writing your own Android applications is a copy of the Android SDK and the Java development kit. Unless you’re a masochist, you’ll probably want a Java IDE — Eclipse is particularly well supported — to make development a little easier.Versions of the SDK, Java, and Eclipse are available for Windows, MacOS, and Linux, so you can explore Android from the comfort of whatever OS you favor. The SDK tools and emula- tor work on all three OS environments, and because Android applications are run on a virtual machine, there’s no advantage to developing from any particular operating system.Android code is written with Java syntax, and the core Android libraries include most of the features from the core Java APIs. Before they can be run, though, your projects must first be translated into Dalvik byte code. As a result, you get the benefits of using Java while your appli- cations have the advantage of running on a virtual machine optimized for mobile devices. ple applications. It also includes tools to help you write and debug your applications, like the Android Emulator to run your projects and the Dalvik Debug Monitoring Service (DDMS) to help debug them.By the end of this chapter you’ll have downloaded the Android SDK, set up your development environment, completed two new applications, and run and debugged them with the DDMS using the emulator running on an Android Virtual Device."
2,Explain why type checking isn’t necessary when assigning or extracting values from each column within a row,"SQLite has a reputation for being extremely reliable and is the database system of choice for many consumer electronic devices, including several MP3 players, the iPhone, and the iPod Touch. Lightweight and powerful, SQLite differs from many conventional database engines by loosely typing each column, meaning that column values are not required to conform to a single type. Instead, each value is typed individually for each row. Hence,type checking isn’t necessary when assigning or extracting values from each column within a row.","By being implemented as a library, rather than running as a separate ongoing process, each SQLite database is an integrated part of the application that created it. This reduces external dependencies, minimizes latency, and simplifies transaction locking and synchronization.SQLite has a reputation for being extremely reliable and is the database system of choice for many consumer electronic devices, including several MP3 players, the iPhone, and the iPod Touch. Lightweight and powerful, SQLite differs from many conventional database engines by loosely typing each column, meaning that column values are not required to conform to a single type. Instead, each value is typed individually for each row. As a result, type checking isn’t necessary when assigning or extracting values from each column within a row. out the official site at http://www.sqlite.org/ CURSORS AND CONTENT VALUES ContentValues are used to insert new rows into tables. Each Content Values object represents a single table row as a map of column names to values.Queries in Android are returned as Cursor objects. Rather than extracting and returning a copy of the result values, Cursors are pointers to the result set within the underlying data. Cursors provide a managed way of controlling your position (row) in the result set of a database query."
3,Explain why any query on the Data table must filter the rows by MIME-type in order to meaningfully extract data,"The Data table is also used for finding details for a given contact. In most cases, you will likely be querying for contact details based on a full or partial contact name. query URI. Append the full or partial name to lookup as an additional path segment to the URI. To extract the associated contact details, find the _ID value from the returned Cursor and use it to create a query on the Data table.The content of each column with a row in the Data table depends on the MIME type specified for that row. Hence,any query on the Data table must filter the rows by MIME-type in order to meaningfully extract data.","Typically you will use the Data table to add, delete, or modify data stored against an existing contact account, the Raw Contacts table to create and manage accounts, and both the Contact and Data tables to query the database and extract contact details. You can use the Content Resolver to query any of the three Contact Contracts tables described above using the CONTENT_URI static constant available from each class. Each class includes a number of static properties that describe the column names included in the underlying tables. In order to access any contact details you need to include the READ_CONTACTS uses-permission in your application manifest: <uses-permission android:name=""android.permission.READ_CONTACTS""/> Listing 7-19 queries the Contacts table for a Cursor to every person in the address book, creating an array of strings that holds each contact’s name and unique ID. // Get a cursor over every aggregated contact. getContentResolver().query(ContactsContract.Contacts.CONTENT_URI, null, null, null, null); // Let the activity manage the cursor lifecycle. // Use the convenience properties to get the index of the columns int nameIdx = cursor.getColumnIndexOrThrow(ContactsContract.Contacts.DISPLAY_NAME); int idIdx = cursor. getColumnIndexOrThrow(ContactsContract.Contacts._ID); String[] result = new String[cursor.getCount()]; if (cursor.moveToFirst()) do { // Extract the name. // Extract the phone number. result[cursor.getPosition()] = name + "" ("" + id + "")""; } while(cursor.moveToNext()); stopManagingCursor(cursor); The ContactsContract.Data Content Provider is used to store all the contact details — such as addresses, phone numbers, and e-mail addresses — making it the best approach when searching for one of these details.The Data table is also used for finding details for a given contact. In most cases, you will likely be querying for contact details based on a full or partial contact name. query URI. Append the full or partial name to lookup as an additional path segment to the URI. To extract the associated contact details, find the _ID value from the returned Cursor and use it to create a query on the Data table.The content of each column with a row in the Data table depends on the MIME type specified for that row. As a result, any query on the Data table must filter the rows by MIME-type in order to meaningfully extract data. Listing 7-20 shows how to use the contact-detail column names available in the CommonDataKinds subclasses to extract the display name and mobile phone number from the Data table for a particular contact. // Find a contact using a partial name match Uri lookupUri = Uri.withAppendedPath(ContactsContract.Contacts.CONTENT_FILTER_URI, ""kristy""); Cursor idCursor = getContentResolver().query(lookupUri, null, null, null, null); String id = null; if (idCursor.moveToFirst()) { int idIdx = idCursor.getColumnIndexOrThrow(ContactsContract.Contacts._ID); id = idCursor.getString(idIdx); } idCursor.close(); if (id != null) { // Return all the contact details of type PHONE for the contact we found String where = ContactsContract.Data.CONTACT_ID + "" = "" + id + "" AND "" + ContactsContract.Data.MIMETYPE + "" = ‘"" + ContactsContract.CommonDataKinds.Phone.CONTENT_ITEM_TYPE + ""’""; Cursor dataCursor = getContentResolver().query(ContactsContract.Data.CONTENT_URI, null, where, null, null); // Use the convenience properties to get the index of the columns int nameIdx = dataCursor.getColumnIndexOrThrow(ContactsContract.Data.DISPLAY_NAME); int phoneIdx = dataCursor.getColumnIndexOrThrow(ContactsContract.CommonDataKinds.Phone.NUMBER) ; String[] result = new String[dataCursor.getCount()]; if (dataCursor.moveToFirst()) do { // Extract the name. // Extract the phone number. result[dataCursor.getPosition()] = name + "" ("" + number + "")""; } while(dataCursor.moveToNext()); dataCursor.close(); } Native Android Content Providers ❘ 243 The Contacts sub-class also offers a phone number lookup URI to help find a contact associated with a particular phone number. This query is highly optimized to return fast results for incoming caller-ID notification. tional path segment, as shown in Listing 7-21. String incomingNumber = ""5551234""; Uri lookupUri = Uri.withAppendedPath(ContactsContract.PhoneLookup.CONTENT_FILTER_URI, incomingNumber); Cursor idCursor = getContentResolver().query(lookupUri, null, null, null, null); if (idCursor.moveToFirst()) { int nameIdx = idCursor.getColumnIndexOrThrow(ContactsContract.Contacts.DISPLAY_NAME); String caller = idCursor.getString(nameIdx); Toast.makeText(getApplicationContext(), caller, Toast.LENGTH_LONG).show(); } idCursor.close(); In addition to the static contact details described above, the ContactsContract.StatusUpdates table contains social status updates and instant messenger availability. Using this table you can look up or modify the status, and presence, of any contact who has an associated social networking and/or instant messaging account. As well as querying the contacts database, you can use these Content Providers to modify, delete, or insert contact records after adding the WRITE_CONTACTS uses-permission to your application manifest.The extensible nature of the Contacts Contract provider allows you to add arbitrary Data table rows to any account stored as a Raw Contact. In practice it is poor form to extend a third-party account with custom data as it will be unable to synchronize your custom data with its online server."
4,Explain why time-consuming processing in any component will block all other components including Services and the visible Activity,"Once your Service no longer requires foreground priority you can move it back to the background, and optionally remove the ongoing notification using the stopForeground method, as shown in Listing 9-8. // Move to the background and remove the Notification stopForeground(true); Prior to Android 2.0 it was possible to set a Service to the foreground using the setForeground method. This method has now been deprecated and will result in a no-op, effectively doing nothing. To ensure that your applications remain responsive, it’s good practice to move all slow, time-consuming operations off the main application thread and onto a child thread. Broadcast Receivers — start on the main application thread. Hence,time-consuming processing in any component will block all other components including Services and the visible Activity.","Later in this chapter you’ll learn how to specify a custom layout for your Notification. Using this technique you can provide more details of your ongoing Service to users.Once your Service no longer requires foreground priority you can move it back to the background, and optionally remove the ongoing notification using the stopForeground method, as shown in Listing 9-8. // Move to the background and remove the Notification stopForeground(true); Prior to Android 2.0 it was possible to set a Service to the foreground using the setForeground method. This method has now been deprecated and will result in a no-op, effectively doing nothing. To ensure that your applications remain responsive, it’s good practice to move all slow, time-consuming operations off the main application thread and onto a child thread. Broadcast Receivers — start on the main application thread. As a result, time-consuming processing in any component will block all other components including Services and the visible Activity. an operation to be performed in the background, then provides event handlers you can use to monitor progress and post the results on the GUI thread.Alternatively, you can implement your own Threads and use the Handler class to synchronize with the GUI thread before updating the UI. Both techniques are described in this section. Using background threads is vital for avoiding the ‘‘Force Close’’ dialog box described in Chapter 2. In Android, Activities that don’t respond to an input event (such as a key press) within five seconds, and Broadcast Receivers that don’t complete theironReceive handlers within 10 seconds, are considered unresponsive."
5,Explain why the multimedia capabilities of mobile devices are a significant consideration for many consumers,"In the following chapter you will explore the audiovisual APIs available in Android. You’ll take a look at multimedia playback and recording using the microphone and camera. Audio, Video, and Using the Camera WHAT’S IN THIS CHAPTER? ➤ Playing audio and video with the Media Player ➤ Packaging audio as an application resource ➤ Using the Video View for video playback ➤ Recording audio and video with the Media Recorder ➤ Recording video and taking pictures using Intents ➤ Previewing recorded video and displaying live camera streams ➤ Taking pictures and controlling the camera ➤ Reading and modifying image EXIF data ➤ Adding media to the Media Store ➤ Manipulating raw audio ➤ Using speech recognition The only modern technology that can compete with mobile phones for ubiquity is the portable digital media player. Hence,the multimedia capabilities of mobile devices are a significant consideration for many consumers.","Listing 10-28 shows the skeleton code for a Wallpaper Service Engine implementation. Refer to Chapter 15 for more details on how to draw on a Surface and use the onTouchEvent handler and Motion Events. public class MyWallpaperServiceEngine extends WallpaperService.Engine { @Override public void onCreate(SurfaceHolder surfaceHolder) { super.onCreate(surfaceHolder); // TODO Handle initialization. Summary ❘ 361 @Override public void onOffsetsChanged(float xOffset, float yOffset, float xOffsetStep, float yOffsetStep, int xPixelOffset, int yPixelOffset) { super.onOffsetsChanged(xOffset, yOffset, xOffsetStep, yOffsetStep, xPixelOffset, yPixelOffset); // TODO Handle homescreen offset events. @Override public void onTouchEvent(MotionEvent event) { super.onTouchEvent(event); // TODO Handle touch and motion events. @Override public void onSurfaceCreated(SurfaceHolder holder) { super.onSurfaceCreated(holder); // TODO Surface has been created, run the Thread that will // update the display. } SUMMARY In this chapter you learned how to create App Widgets and Live Folders for your application. ➤ Implement widgets and add them to your applications. Control the update rate of your widgets by setting the minimum refresh rate or using Intents and Alarms. Update the UI of your widgets using Remote Views. Add interactivity to your widgets. Create and register a Live Folder for your application’s Content Provider. Add a projection to your Content Provider to provide a Live Folder schema. Create and use Live Wallpaper. Add search to your application and surface search results to the Quick Search Box.In the following chapter you will explore the audiovisual APIs available in Android. You’ll take a look at multimedia playback and recording using the microphone and camera. Audio, Video, and Using the Camera WHAT’S IN THIS CHAPTER? ➤ Playing audio and video with the Media Player ➤ Packaging audio as an application resource ➤ Using the Video View for video playback ➤ Recording audio and video with the Media Recorder ➤ Recording video and taking pictures using Intents ➤ Previewing recorded video and displaying live camera streams ➤ Taking pictures and controlling the camera ➤ Reading and modifying image EXIF data ➤ Adding media to the Media Store ➤ Manipulating raw audio ➤ Using speech recognition The only modern technology that can compete with mobile phones for ubiquity is the portable digital media player. As a result, the multimedia capabilities of mobile devices are a significant consideration for many consumers. API capable of playing and recording a wide range of image, audio, and video formats, both locally and streamed. cations, providing comprehensive multimedia functionality. In this chapter you’ll learn how to play and record multimedia content including audio, video, and still images, as well as use the camera to capture images and preview and record live video.You’ll also learn how to manipulate raw audio files using the Audio Track and Audio Record classes, add newly recorded media files to the Media Store, and make use of speech recognition to add voice input to your applications. Android includes a comprehensive Media Player to simplify the playback of audio and video. This section describes how to use it to control and manipulate media playback within your applications."
6,Explain why it’s good practice to insert it into the Media Store to make it available to other applications,"To read an EXIF attribute, call getAttribute on the ExifInterface object, passing in the name of the attribute to read. The Exifinterface class includes a number of static TAG_* constants that can be used to access common EXIF metadata. To modify an EXIF attribute, use setAttribute, passing in the name of the attribute to read and the value to set it to.Listing 11-19 shows how to read the location coordinates and camera model from a file stored on the SD card, before modifying the camera manufacturer details. File file = new File(Environment.getExternalStorageDirectory(), ""test.jpg""); try { ExifInterface exif = new ExifInterface(file.getCanonicalPath()); // Read the camera model and location attributes String model = exif.getAttribute(ExifInterface.TAG_MODEL); float[] latLng = new float[2]; exif.getLatLong(latLng); // Set the camera make exif.setAttribute(ExifInterface.TAG_MAKE, ""My Phone""); } catch (IOException e) { Log.d(""EXIF"", e.getMessage()); } ADDING NEW MEDIA TO THE MEDIA STORE By default, media files created by your application will be unavailable to other applications. Hence,it’s good practice to insert it into the Media Store to make it available to other applications.","Listing 11-18 shows the skeleton code for taking a picture and saving the JPEG image to the SD card. private void takePicture() { camera.takePicture(shutterCallback, rawCallback, jpegCallback); } ShutterCallback shutterCallback = new ShutterCallback() { public void onShutter() { // TODO Do something when the shutter closes. }; PictureCallback rawCallback = new PictureCallback() { public void onPictureTaken(byte[] data, Camera camera) { // TODO Do something with the image RAW data. }; PictureCallback jpegCallback = new PictureCallback() { public void onPictureTaken(byte[] data, Camera camera) { // Save the image JPEG data to the SD card FileOutputStream outStream = null; try { outStream = new FileOutputStream(""/sdcard/test.jpg""); outStream.write(data); outStream.close(); } catch (FileNotFoundException e) { Log.d(""CAMERA"", e.getMessage()); } catch (IOException e) { Log.d(""CAMERA"", e.getMessage()); } } }; Reading and Writing JPEG EXIF Image Details The ExifInterface class provides mechanisms for you to read and modify the EXIF (Exchangeable Image File Format) data stored within a JPEG file. Create a new ExifInterface instance by passing the full filename in to the constructor. 382 ❘ CHAPTER 11 AUDIO, VIDEO, AND USING THE CAMERA EXIF data is used to store a wide range of metadata on photographs, including date and time, camera settings (such as make and model), and image settings (such as aperture and shutter speed), as well as image descriptions and locations.To read an EXIF attribute, call getAttribute on the ExifInterface object, passing in the name of the attribute to read. The Exifinterface class includes a number of static TAG_* constants that can be used to access common EXIF metadata. To modify an EXIF attribute, use setAttribute, passing in the name of the attribute to read and the value to set it to.Listing 11-19 shows how to read the location coordinates and camera model from a file stored on the SD card, before modifying the camera manufacturer details. File file = new File(Environment.getExternalStorageDirectory(), ""test.jpg""); try { ExifInterface exif = new ExifInterface(file.getCanonicalPath()); // Read the camera model and location attributes String model = exif.getAttribute(ExifInterface.TAG_MODEL); float[] latLng = new float[2]; exif.getLatLong(latLng); // Set the camera make exif.setAttribute(ExifInterface.TAG_MAKE, ""My Phone""); } catch (IOException e) { Log.d(""EXIF"", e.getMessage()); } ADDING NEW MEDIA TO THE MEDIA STORE By default, media files created by your application will be unavailable to other applications. As a result, it’s good practice to insert it into the Media Store to make it available to other applications.Android provides two alternatives for inserting media into the Media Store, either using the Media Scanner to interpret your file and insert it automatically, or manually inserting a new record in the appropriate Content Provider. If you have recorded new media of any kind, the MediaScannerConnection class provides a simple way for you to add it to the Media Store without needing to construct the full record for the Media Store Content Provider."
7,Explain why an accelerometer detecting acceleration on the z-axis (up/down) will read -9,"You should always check for the availability of any required Sensors and make sure your applications fail gracefully if they are missing. Accelerometers, as their name suggests, are used to measure acceleration. They are also sometimes referred to as gravity sensors. Accelerometers are also known as gravity sensors because of their inability to differentiate between acceleration caused by movement and gravity. Hence,an accelerometer detecting acceleration on the z-axis (up/down) will read -9.","In recent years these sensors have become increasingly common, having found their way into game controllers like the Nintendo Wii and mobile smartphone handsets like the Apple iPhone, Palm Pre, and many Android devices. and movement. A recent trend is to use this functionality to provide input mechanisms other than the traditional touchscreen, trackball, and keyboard. cation runs. When available, they are exposed through the Sensor Manager, allowing you to do the following: ➤ Determine the current device orientation ➤ Monitor and track changes in orientation ➤ Know which direction the user is facing ➤ Monitor acceleration — changes in movement rate — in any direction: vertically, laterally, or longitudinally This opens some intriguing possibilities for your applications. By monitoring orientation, direction, and movement, you can: ➤ Use the compass and accelerometer to determine your speed and direction. Use these with a map, camera, and location-based services to create augmented reality interfaces that overlay location-based data over the real-time camera feed. Create user interfaces that adjust dynamically to suit the orientation of your device. Android already alters the native screen orientation when the device is rotated from portrait to land- scape or vice versa. Monitor for rapid acceleration to detect if a device has been dropped or thrown. Measure movement or vibration. For example you could create an application that lets you lock your device; if any movement is detected while it’s locked it could send an alert SMS that includes the current location. Create user interface controls that use physical gestures and movement as input.You should always check for the availability of any required Sensors and make sure your applications fail gracefully if they are missing. Accelerometers, as their name suggests, are used to measure acceleration. They are also sometimes referred to as gravity sensors. Accelerometers are also known as gravity sensors because of their inability to differentiate between acceleration caused by movement and gravity. As a result, an accelerometer detecting acceleration on the z-axis (up/down) will read -9.8m/s2 when it’s at rest (this value is available as the SensorManager.STANDARD_GRAVITY constant).Acceleration is defined as the rate of change of velocity, so accelerometers measure how quickly the speed of the device is changing in a given direction. Using an accelerometer you can detect movement and, more usefully, the rate of change of the speed of that movement."
8,Explain why all of the advanced features described so far in this section can be used to enhance map Overlays,"All that’s left is to draw two more circles as clean borders for the inner and outer face bound- aries. Then restore the canvas to upright, and finish the onDraw method. canvas.drawOval(boundingBox, circlePaint); // Draw the inner ring circlePaint.setStrokeWidth(2); canvas.drawOval(innerBoundingBox, circlePaint); canvas.restore(); } All code snippets in this example are part of the Chapter 15 Artificial Horizon project, available for download at Wrox.com. In Chapter 8, you learned how to use Overlays to add annotation layers to Map Views. The Canvas used for annotating Map View Overlays is the same class as the one used to draw new View controls. Hence,all of the advanced features described so far in this section can be used to enhance map Overlays.","Start by adding a ‘‘glass dome’’ over the top to give the illusion of a watch face. Using the radial gradient array you constructed earlier, create a new Shader and Paint object. Use them to draw a circle over the inner face that makes it look like it’s covered in glass. new RadialGradient(px, py, (int)innerRadius, glassGradientColors, glassGradientPositions, TileMode.CLAMP); Paint glassPaint = new Paint(); glassPaint.setShader(glassShader); canvas.drawOval(innerBoundingBox, glassPaint); 516 ❘ CHAPTER 15 ADVANCED ANDROID DEVELOPMENT 18.All that’s left is to draw two more circles as clean borders for the inner and outer face bound- aries. Then restore the canvas to upright, and finish the onDraw method. canvas.drawOval(boundingBox, circlePaint); // Draw the inner ring circlePaint.setStrokeWidth(2); canvas.drawOval(innerBoundingBox, circlePaint); canvas.restore(); } All code snippets in this example are part of the Chapter 15 Artificial Horizon project, available for download at Wrox.com. In Chapter 8, you learned how to use Overlays to add annotation layers to Map Views. The Canvas used for annotating Map View Overlays is the same class as the one used to draw new View controls.As a result, all of the advanced features described so far in this section can be used to enhance map Overlays.That means you can use any of the draw methods, transparency, Shaders, Color Masks, and Filter Effects to create rich Overlays using the Android graphics framework."
