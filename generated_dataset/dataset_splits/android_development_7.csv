,Question,Answer,Context
0,"Explain why on every key press, the whole puzzle had to be redrawn","Now let’s provide a way for the player to enter a new number on the selected tile. To handle keyboard input, we just add a few more cases to the onKey- Down( ) method for the numbers 0 through 9 (0 or space means erase the number). case KeyEvent.KEYCODE_0: case KeyEvent.KEYCODE_SPACE: setSelectedTile(0); break; case KeyEvent.KEYCODE_1: setSelectedTile(1); break; case KeyEvent.KEYCODE_2: setSelectedTile(2); break; case KeyEvent.KEYCODE_3: setSelectedTile(3); break; case KeyEvent.KEYCODE_4: setSelectedTile(4); break; case KeyEvent.KEYCODE_5: setSelectedTile(5); break; case KeyEvent.KEYCODE_6: setSelectedTile(6); break; case KeyEvent.KEYCODE_7: setSelectedTile(7); break; case KeyEvent.KEYCODE_8: setSelectedTile(8); break; case KeyEvent.KEYCODE_9: setSelectedTile(9); break; case KeyEvent.KEYCODE_ENTER: case KeyEvent.KEYCODE_DPAD_CENTER: game.showKeypadOrError(selX, selY); break; HANDLING INPUT 87 Optimizing Refreshes In an earlier version of this example, I invalidated the entire screen whenever the cursor was moved. Hence,on every key press, the whole puzzle had to be redrawn.","Inside the select( ) method, we calculate the new x and y coordinate of the selection and then use getRect( ) again to calculate the new selection rectangle. 86 Download Sudokuv2/src/org/example/sudoku/PuzzleView.java private void select(int x, int y) { invalidate(selRect); selX = Math.min(Math.max(x, 0), 8); selY = Math.min(Math.max(y, 0), 8); getRect(selX, selY, selRect); invalidate(selRect); } Notice the two calls to invalidate( ). The first one tells Android that the area covered by the old selection rectangle (on the left of Figure 4.5, on the preceding page) needs to be redrawn. The second invalidate( ) call says that the new selection area (on the right of the figure) needs to be redrawn too. We don’t actually draw anything here. the onDraw( ) method. Instead, you use the invalidate( ) method to mark rectangles as dirty. The window manager will combine all the dirty rect- angles at some point in the future and call onDraw( ) again for you. The dirty rectangles become the clip region, so screen updates are optimized to only those areas that change.Now let’s provide a way for the player to enter a new number on the selected tile. To handle keyboard input, we just add a few more cases to the onKey- Down( ) method for the numbers 0 through 9 (0 or space means erase the number). case KeyEvent.KEYCODE_0: case KeyEvent.KEYCODE_SPACE: setSelectedTile(0); break; case KeyEvent.KEYCODE_1: setSelectedTile(1); break; case KeyEvent.KEYCODE_2: setSelectedTile(2); break; case KeyEvent.KEYCODE_3: setSelectedTile(3); break; case KeyEvent.KEYCODE_4: setSelectedTile(4); break; case KeyEvent.KEYCODE_5: setSelectedTile(5); break; case KeyEvent.KEYCODE_6: setSelectedTile(6); break; case KeyEvent.KEYCODE_7: setSelectedTile(7); break; case KeyEvent.KEYCODE_8: setSelectedTile(8); break; case KeyEvent.KEYCODE_9: setSelectedTile(9); break; case KeyEvent.KEYCODE_ENTER: case KeyEvent.KEYCODE_DPAD_CENTER: game.showKeypadOrError(selX, selY); break; HANDLING INPUT 87 Optimizing Refreshes In an earlier version of this example, I invalidated the entire screen whenever the cursor was moved. Thus, on every key press, the whole puzzle had to be redrawn. This caused it to lag noticeably. Switching the code to invalidate only the smallest rectangles that changed made it run much faster.To support the D-pad, we check for the Enter or center D-pad button in onKeyDown( ) and have it pop up a keypad that lets the user select which number to place. keypad, which will be defined later: Download Sudokuv2/src/org/example/sudoku/PuzzleView.java @Override public boolean onTouchEvent(MotionEvent event) { if (event.getAction() != MotionEvent.ACTION_DOWN) return super.onTouchEvent(event); select((int) (event.getX() / width), (int) (event.getY() / height)); game.showKeypadOrError(selX, selY); Log.d(TAG, ""onTouchEvent: x "" + selX + "", y "" + selY); return true; } Ultimately, all roads will lead back to a call to setSelectedTile( ) to change the number on a tile: Download Sudokuv2/src/org/example/sudoku/PuzzleView.java public void setSelectedTile(int tile) { if (game.setTileIfValid(selX, selY, tile)) { invalidate();// may change hints } else { // Number is not valid for this tile Log.d(TAG, ""setSelectedTile: invalid: "" + tile); } } The showKeypadOrError( ) and setTileIfValid( ) methods will be defined in Section 4.4, The Rest of the Story, on page 90. 88 Note the call to invalidate( ) with no parameters. That marks the whole screen as dirty, which violates my own advice earlier! However, in this case, it’s necessary because any new numbers added or removed might change the hints that we are about to implement in the next section. How can we help the player out a little without solving the whole puzzle for them? How about if we draw the background of each tile differently depending on how many possible moves it has. Add this to onDraw( ) before drawing the selection: Download Sudokuv2/src/org/example/sudoku/PuzzleView.java // Draw the hints... // Pick a hint color based on #moves left Paint hint = new Paint(); int c[] = { getResources().getColor(R.color.puzzle_hint_0), getResources().getColor(R.color.puzzle_hint_1), getResources().getColor(R.color.puzzle_hint_2), }; Rect r = new Rect(); for (int i = 0; i < 9; i++) { for (int j = 0; j < 9; j++) { int movesleft = 9 - game.getUsedTiles(i, j).length; if (movesleft < c.length) { getRect(i, j, r); hint.setColor(c[movesleft]); canvas.drawRect(r, hint); } } } We use three states for zero, one, and two possible moves. If there are zero moves, that means the player has done something wrong and needs to backtrack."
