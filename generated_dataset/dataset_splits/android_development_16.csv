,Question,Answer,Context
0,"Explain why on every key press, the whole puzzle had to be redrawn","Now let’s provide a way for the player to enter a new number on the selected tile. To handle keyboard input, we just add a few more cases to the onKey- Down( ) method for the numbers 0 through 9 (0 or space means erase the number). From Library of Wow! eBook this copy is (P1.0 printing, July 2010) HANDLING INPUT 90 Optimizing Refreshes In an earlier version of this example, I invalidated the entire screen whenever the cursor was moved. Hence,on every key press, the whole puzzle had to be redrawn.","Inside the select( ) method, we calculate the new x and y coordinates of the selection and then use getRect( ) again to calculate the new selection rectangle. private void select(int x, int y) { invalidate(selRect); selX = Math.min(Math.max(x, 0), 8); selY = Math.min(Math.max(y, 0), 8); getRect(selX, selY, selRect); invalidate(selRect); } Notice the two calls to invalidate( ). The first one tells Android that the area covered by the old selection rectangle (on the left of Figure 4.5, on the previous page) needs to be redrawn. The second invalidate( ) call says that the new selection area (on the right of the figure) needs to be redrawn too. We don’t actually draw anything here. the onDraw( ) method. Instead, you use the invalidate( ) method to mark rectangles as dirty. The window manager will combine all the dirty rect- angles at some point in the future and call onDraw( ) again for you. The dirty rectangles become the clip region, so screen updates are optimized to only those areas that change.Now let’s provide a way for the player to enter a new number on the selected tile. To handle keyboard input, we just add a few more cases to the onKey- Down( ) method for the numbers 0 through 9 (0 or space means erase the number). From Library of Wow! eBook this copy is (P1.0 printing, July 2010) HANDLING INPUT 90 Optimizing Refreshes In an earlier version of this example, I invalidated the entire screen whenever the cursor was moved. Thus, on every key press, the whole puzzle had to be redrawn. This caused it to lag noticeably. Switching the code to invalidate only the smallest rectangles that changed made it run much faster. case KeyEvent.KEYCODE_0: case KeyEvent.KEYCODE_SPACE: setSelectedTile(0); break; case KeyEvent.KEYCODE_1: setSelectedTile(1); break; case KeyEvent.KEYCODE_2: setSelectedTile(2); break; case KeyEvent.KEYCODE_3: setSelectedTile(3); break; case KeyEvent.KEYCODE_4: setSelectedTile(4); break; case KeyEvent.KEYCODE_5: setSelectedTile(5); break; case KeyEvent.KEYCODE_6: setSelectedTile(6); break; case KeyEvent.KEYCODE_7: setSelectedTile(7); break; case KeyEvent.KEYCODE_8: setSelectedTile(8); break; case KeyEvent.KEYCODE_9: setSelectedTile(9); break; case KeyEvent.KEYCODE_ENTER: case KeyEvent.KEYCODE_DPAD_CENTER: game.showKeypadOrError(selX, selY); break; To support the D-pad, we check for the Enter or center D-pad button in onKeyDown( ) and have it pop up a keypad that lets the user select which number to place. keypad, which will be defined later: Download Sudokuv2/src/org/example/sudoku/PuzzleView.java @Override public boolean onTouchEvent(MotionEvent event) { if (event.getAction() != MotionEvent.ACTION_DOWN) return super.onTouchEvent(event); select((int) (event.getX() / width), (int) (event.getY() / height)); game.showKeypadOrError(selX, selY); Log.d(TAG, ""onTouchEvent: x "" + selX + "", y "" + selY); return true; } Report erratum From Library of Wow! eBook this copy is (P1.0 printing, July 2010) HANDLING INPUT 91 Ultimately, all roads will lead back to a call to setSelectedTile( ) to change the number on a tile: Download Sudokuv2/src/org/example/sudoku/PuzzleView.java public void setSelectedTile(int tile) { if (game.setTileIfValid(selX, selY, tile)) { invalidate();// may change hints } else { // Number is not valid for this tile Log.d(TAG, ""setSelectedTile: invalid: "" + tile); } } The showKeypadOrError( ) and setTileIfValid( ) methods will be defined in Section 4.4, The Rest of the Story, on page 93. screen as dirty, which violates my own advice earlier! However, in this case, it’s necessary because any new numbers added or removed might change the hints that we are about to implement in the next section. How can we help the player out a little without solving the whole puzzle for them? How about if we draw the background of each tile differently depending on how many possible moves it has. Add this to onDraw( ) before drawing the selection: Download Sudokuv2/src/org/example/sudoku/PuzzleView.java // Draw the hints... // Pick a hint color based on #moves left Paint hint = new Paint(); int c[] = { getResources().getColor(R.color.puzzle_hint_0), getResources().getColor(R.color.puzzle_hint_1), getResources().getColor(R.color.puzzle_hint_2), }; Rect r = new Rect(); for (int i = 0; i < 9; i++) { for (int j = 0; j < 9; j++) { int movesleft = 9 - game.getUsedTiles(i, j).length; if (movesleft < c.length) { getRect(i, j, r); hint.setColor(c[movesleft]); canvas.drawRect(r, hint); } } } Report erratum From Library of Wow! eBook this copy is (P1.0 printing, July 2010) HANDLING INPUT 92 Figure 4.6: Tiles are highlighted based on how many possible values the tile can have.We use three states for zero, one, and two possible moves. If there are zero moves, that means the player has done something wrong and needs to backtrack. by the player?2 Shaking Things Up What if the user tries to enter an obviously invalid number, such as a number that already appears in the three-by-three block? Just for fun, let’s make the screen wiggle back and forth when they do that. First we add a call to the invalid number case in setSelectedTile( ). From Library of Wow! eBook this copy is (P1.0 printing, July 2010) THE REST OF THE STORY 93 Download Sudokuv2/src/org/example/sudoku/PuzzleView.java Log.d(TAG, ""setSelectedTile: invalid: "" + tile); startAnimation(AnimationUtils.loadAnimation(game, R.anim.shake)); This loads and runs a resource called R.anim.shake, defined in res/anim/ shake.xml, that shakes the screen for 1,000 milliseconds (1 second) by 10 pixels from side to side. <?xml version=""1.0"" encoding=""utf-8""?> <translate xmlns:android=""http://schemas.android.com/apk/res/android"" android:fromXDelta=""0"" android:toXDelta=""10"" android:duration=""1000"" android:interpolator=""@anim/cycle_7"" /> The number of times to run the animation and the velocity and accel- eration of the animation are controlled by an animation interpolator defined in XML. <?xml version=""1.0"" encoding=""utf-8""?> <cycleInterpolator xmlns:android=""http://schemas.android.com/apk/res/android"" android:cycles=""7"" /> This particular one will cause the animation to be repeated seven times. The Rest of the Story Now let’s go back and tie up a few loose ends, starting with the Key- pad class. These pieces are necessary for the program to compile and operate but have nothing to do with graphics. Feel free to skip ahead to Section 4.5, Making More Improvements, on page 103 if you like. The keypad is handy for phones that don’t have keyboards. It displays a grid of the numbers 1 through 9 in an activity that appears on top of the puzzle. The whole purpose of the keypad dialog box is to return a number selected by the player. From Library of Wow! eBook this copy is (P1.0 printing, July 2010) THE REST OF THE STORY 94 Here’s the user interface layout from res/layout/keypad.xml: Download Sudokuv2/res/layout/keypad.xml <?xml version=""1.0"" encoding=""utf-8""?> <TableLayout xmlns:android=""http://schemas.android.com/apk/res/android"" android:id=""@+id/keypad"" android:orientation=""vertical"" android:layout_width=""wrap_content"" android:layout_height=""wrap_content"" android:stretchColumns=""*"" > <TableRow> <Button android:id=""@+id/keypad_1"" android:text=""1"" > </Button> <Button android:id=""@+id/keypad_2"" android:text=""2"" > </Button> <Button android:id=""@+id/keypad_3"" android:text=""3"" > </Button> </TableRow> <TableRow> <Button android:id=""@+id/keypad_4"" android:text=""4"" > </Button> <Button android:id=""@+id/keypad_5"" android:text=""5"" > </Button> <Button android:id=""@+id/keypad_6"" android:text=""6"" > </Button> </TableRow> <TableRow> <Button android:id=""@+id/keypad_7"" android:text=""7"" > </Button> <Button android:id=""@+id/keypad_8"" android:text=""8"" > </Button> <Button android:id=""@+id/keypad_9"" android:text=""9"" > </Button> </TableRow> </TableLayout> Next let’s define the Keypad class. From Library of Wow! eBook this copy is (P1.0 printing, July 2010) THE REST OF THE STORY 95 Here’s the outline: Download Sudokuv2/src/org/example/sudoku/Keypad.java package org.example.sudoku; import android.app.Dialog; import android.content.Context; import android.os.Bundle; import android.view.KeyEvent; import android.view.View; public class Keypad extends Dialog { protected static final String TAG = ""Sudoku"" ; private final View keys[] = new View[9]; private View keypad; private final int useds[]; private final PuzzleView puzzleView; public Keypad(Context context, int useds[], PuzzleView puzzleView) { super(context); this.useds = useds; this.puzzleView = puzzleView; } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setTitle(R.string.keypad_title); setContentView(R.layout.keypad); findViews(); for (int element : useds) { if (element != 0) keys[element - 1].setVisibility(View.INVISIBLE); } setListeners(); } // ... } If a particular number is not valid (for example, the same number already appears in that row), then we make the number invisible in the grid so the player can’t select it (see Figure 4.7, on the next page). From Library of Wow! eBook this copy is (P1.0 printing, July 2010) THE REST OF THE STORY 96 Figure 4.7: Invalid values are hidden in the keypad view. keys and the main keypad window: Download Sudokuv2/src/org/example/sudoku/Keypad.java private void findViews() { keypad = findViewById(R.id.keypad); keys[0] = findViewById(R.id.keypad_1); keys[1] = findViewById(R.id.keypad_2); keys[2] = findViewById(R.id.keypad_3); keys[3] = findViewById(R.id.keypad_4); keys[4] = findViewById(R.id.keypad_5); keys[5] = findViewById(R.id.keypad_6); keys[6] = findViewById(R.id.keypad_7); keys[7] = findViewById(R.id.keypad_8); keys[8] = findViewById(R.id.keypad_9); } setListeners( ) loops through all the keypad keys and sets a listener for each one. It also sets a listener for the main keypad window. From Library of Wow! eBook this copy is (P1.0 printing, July 2010) THE REST OF THE STORY 97 Download Sudokuv2/src/org/example/sudoku/Keypad.java private void setListeners() { for (int i = 0; i < keys.length; i++) { final int t = i + 1; keys[i].setOnClickListener(new View.OnClickListener(){ public void onClick(View v) { returnResult(t); }}); } keypad.setOnClickListener(new View.OnClickListener(){ public void onClick(View v) { returnResult(0); }}); } When the player selects one of the buttons on the keypad, it calls the returnResult( ) method with the number for that button. If the player selects a place that doesn’t have a button, then returnResult( ) is called with a zero, indicating the tile should be erased. number: Download Sudokuv2/src/org/example/sudoku/Keypad.java @Override public boolean onKeyDown(int keyCode, KeyEvent event) { int tile = 0; switch (keyCode) { case KeyEvent.KEYCODE_0: case KeyEvent.KEYCODE_SPACE: tile = 0; break; case KeyEvent.KEYCODE_1: tile = 1; break; case KeyEvent.KEYCODE_2: tile = 2; break; case KeyEvent.KEYCODE_3: tile = 3; break; case KeyEvent.KEYCODE_4: tile = 4; break; case KeyEvent.KEYCODE_5: tile = 5; break; case KeyEvent.KEYCODE_6: tile = 6; break; case KeyEvent.KEYCODE_7: tile = 7; break; case KeyEvent.KEYCODE_8: tile = 8; break; case KeyEvent.KEYCODE_9: tile = 9; break; default: return super.onKeyDown(keyCode, event); } if (isValid(tile)) { returnResult(tile); } return true; } Report erratum From Library of Wow! eBook this copy is (P1.0 printing, July 2010) THE REST OF THE STORY 98 If the number is valid for the current tile, then it calls returnResult( ); otherwise, the keystroke is ignored. the current position: Download Sudokuv2/src/org/example/sudoku/Keypad.java private boolean isValid(int tile) { for (int t : useds) { if (tile == t) return false; } return true; } If it appears in the used array, then it’s not valid because the same number is already used in the current row, column, or block. calling activity: Download Sudokuv2/src/org/example/sudoku/Keypad.java private void returnResult(int tile) { puzzleView.setSelectedTile(tile); dismiss(); } We call the PuzzleView.setSelectedTile() method to change the puzzle’s cur- rent tile. The dismiss call terminates the Keypad dialog box. Now that we have the activity, let’s call it in the Game class and retrieve the result: Download Sudokuv2/src/org/example/sudoku/Game.java protected void showKeypadOrError(int x, int y) { int tiles[] = getUsedTiles(x, y); if (tiles.length == 9) { Toast toast = Toast.makeText(this, R.string.no_moves_label, Toast.LENGTH_SHORT); toast.setGravity(Gravity.CENTER, 0, 0); toast.show(); } else { Log.d(TAG, ""showKeypad: used="" + toPuzzleString(tiles)); Dialog v = new Keypad(this, tiles, puzzleView); v.show(); } } To decide which numbers are possible, we pass the Keypad a string in the extraData area containing all the numbers that have already been used. From Library of Wow! eBook this copy is (P1.0 printing, July 2010) THE REST OF THE STORY 99 Implementing the Game Logic The rest of the code in Game.java concerns itself with the logic of the game, in particular with determining which are and aren’t valid moves according to the rules. The setTileIfValid( ) method is a key part of that."
