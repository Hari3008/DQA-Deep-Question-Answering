,Question,Answer,Context
0,Explain why the callback that we pass into the SBDownloadBucket that we prepare to hold the result of the HTTP download is a reference to self,"The only wrinkle in this process is that the request will run in an asynchronous fashion, and hence we have to handle the callback. The callback gets passed into the pushInsert, pushUpdate, and pushDelete methods—we pass this all the way through to executeODataOperation and store it in the callback property that we built before. However, when the request is done, we want to capture the result and then decide whether we want to call the method that indicates success or the method that indicates failure on callback. Hence,the callback that we pass into the SBDownloadBucket that we prepare to hold the result of the HTTP download is a reference to self.","However, it’s worth mentioning the BAD_CAST calls. This is a macro defined in the Libxml2 headers that is needed to cast strings. I’m not entirely sure why it’s called a “bad cast”—seems to me that anything that makes it work is a “good cast”! When we issue an OData change request to the server, the URL will refer either to a specific entity (for updates and deletes) or to the class (for inserts). We already have a method called getServiceUrl, which returns back a URL to the class based on an entity type. We can now extend this to return a URL for a specific entity. Here’s the implementation: // Add method to SBODataServiceProxy.m… // <…> Needs declaration in header -(NSString *)getEntityUrlForPush:(SBEntity *)theEntity serverId:(int)theServerId { return [NSString stringWithFormat:@""%@(%d)"", [self getServiceUrl:theEntity.entityType], theServerId]; } Before we look at the executeODataOperation implementation, we’ll add pushInsert and pushDelete, as these are easy. pushInsert defers to pushUpdate, but uses a different URL. pushDelete just defers to executeODataOperation. Here they are: // Add methods to SBODataServiceProxy.m… // <…> Needs declaration in header -(void)pushDelete:(SBEntity *)entity serverId:(int)theServerId callback:(SBODataFetchCallback *)theCallback { // get... NSString *url = [self getEntityUrlForPush:entity serverId:theServerId]; [self executeODataOperation:SBODODelete url:url xml:nil callback:theCallback]; } 421 CHAPTER 11 ■ IOS: PUSHING CHANGES BACK TO THE SERVER // <…> Needs declaration in header -(void)pushInsert:(SBEntity *)entity callback:(SBODataFetchCallback *)theCallback { // an insert is an update but with a different url... [self pushUpdate:entity serverId:0 callback:theCallback]; } Implementing executeODataOperation In the Android application, when we looked at the equivalent method, we learned that each of the three options requires different HTTP methods. Specifically, we learned that insert requires a POST, update requires a MERGE, and delete requires a DELETE. We already know that all of the HTTP requests to the service require our special x-amx-apiusername and x-amx-token headers provided through our getDownloadSettings method. Hence all we have to do is package up an appropriate request and send it.The only wrinkle in this process is that the request will run in an asynchronous fashion, and hence we have to handle the callback. The callback gets passed into the pushInsert, pushUpdate, and pushDelete methods—we pass this all the way through to executeODataOperation and store it in the callback property that we built before. However, when the request is done, we want to capture the result and then decide whether we want to call the method that indicates success or the method that indicates failure on callback. Hence the callback that we pass into the SBDownloadBucket that we prepare to hold the result of the HTTP download is a reference to self. OPCODE_ODATACHANGE. Here’s the revised definition: // Modify SBOpCodes in SBServiceProxy.h… typedef enum { OPCODE_APILOGON = 1000, OPCODE_USERSLOGON = 2000, OPCODE_ODATAFETCHALL = 3000, OPCODE_ODATACHANGE = 3001 } SBOpCodes; Here’s the implementation of executeODataOperation: // Add method to SBODataServiceProxy.m // <…> Needs declaration in header -(void)executeODataOperation:(SBODataOperation)opType url:(NSString*)theUrl xml: (NSString *)theXml callback:(SBODataFetchCallback *)theCallback { // store the callback... self.callback = theCallback; // create a request... NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL: [NSURL URLWithString:theUrl]]; [request setValue:@""application/atom+xml"" forHTTPHeaderField:@""Content-type""]; 422 CHAPTER 11 ■ IOS: PUSHING CHANGES BACK TO THE SERVER // what method? if(opType == SBODOInsert) [request setHTTPMethod:@""POST""]; else if(opType == SBODOUpdate) [request setHTTPMethod:@""MERGE""]; else if(opType == SBODODelete) [request setHTTPMethod:@""DELETE""]; else @throw [NSException exceptionWithName:[[self class] description] reason:@""Unhandled operation type."" userInfo:nil]; // get the settings... SBDownloadSettings *settings = [self getDownloadSettings]; for(NSString *name in settings.extraHeaders) { NSString * value = [settings.extraHeaders objectForKey:name]; [request addValue:value forHTTPHeaderField:name]; } [settings release]; // set the body... if(theXml != nil && theXml.length > 0) [request setHTTPBody:[theXml dataUsingEncoding:NSUTF8StringEncoding]]; // create the connection with the request and start loading the data SBDownloadBucket *bucket = [[SBDownloadBucket alloc] initWithCallback:(SBDownloadCallback *)self opCode:OPCODE_ODATACHANGE]; NSURLConnection *connection = [[NSURLConnection alloc] initWithRequest: request delegate:bucket]; if(connection != nil) NSLog(@""Connection started...""); } Once the HTTP operation has completed, we’ll receive notification into our downloadComplete method. This is currently coded up to understand OPCODE_ODATAFETCHALL. We need to modify this so that it additionally understands OPCODE_ODATACHANGE and defer to a new method called handleODataChangeComplete. Here is the revised implementation of downloadComplete: // Modify downloadComplete method in SBODataServiceProxy… -(void)downloadComplete:(SBDownloadBucket *)bucket { // did we fail - i.e. not 200, not 204 (OK, but nothing to say) and not 201 (""created"")... if(bucket.statusCode != 200 && bucket.statusCode != 204 && bucket.statusCode != 201) { // create an error... NSString *message = [NSString stringWithFormat:@""An OData request returned HTTP status '%d'."", bucket.statusCode]; 423 CHAPTER 11 ■ IOS: PUSHING CHANGES BACK TO THE SERVER NSString *html = bucket.dataAsString; NSLog(@""%@ --> %@"", message, html); NSError *err = [SBErrorHelper error:self message:message]; // flip back... [self.callback odataFetchFailed:err opCode:bucket.opCode]; } else { // ok... if(bucket.opCode == OPCODE_ODATAFETCHALL) [self handleFetchAllComplete:bucket]; else if(bucket.opCode == OPCODE_ODATACHANGE) [self handleODataChangeComplete:bucket]; else @throw [NSException exceptionWithName:[[self class] description] reason:[NSString stringWithFormat:@""An op code of '%d' was not recognised."", [bucket opCode]] userInfo:nil]; } } As previously, we haven’t implemented handleODataChangeComplete, but it’s very easy—it simply defers to our callback. Here’s the implementation: // Add method to SBODataServiceProxy.m… // <…> Needs declaration in header -(void)handleODataChangeComplete:(SBDownloadBucket *)bucket { // good, tell the callback that we did it... [self.callback odataFetchOk:nil opCode:bucket.opCode]; Download from Wow! eBook <www.wowebook.com> } We’re now at a point where once we kick off an OData request, we can send it to the server, receive a callback into the proxy and then hand that callback back to the originator of the request. The next stage is to modify the processWorkItems method that we stubbed earlier so that it does something meaningful. Recall that we have an array of work items stored in our workItems property and that processWorkItems is called as soon as the queue has been initialized. The first operation that processWorkItems will undertake will be to look at the current workItemIndex in relation to the list of work items. If workItemIndex is the same as the length of workItems, there is no more work to be done and getLatest can be called. If there is work to be done, the bookmark referenced from workItemIndex can be handed over the service proxy. // Replace method in SBSync.m… -(void)processWorkItems { 424 CHAPTER 11 ■ IOS: PUSHING CHANGES BACK TO THE SERVER // are we at the end of the list? if so... time to get latest... if(self.workItemIndex == [self.workItems count]) { // return... [self getLatest]; return; } // get the work item... SBSyncWorkItem *item = [self.workItems objectAtIndex:self.workItemIndex]; NSLog(@""Syncing: %d, %d, %@"", item.mode, item.serverId, [[item.entity class] description]); // call the service... SBBookmarksService *service = [[SBBookmarksService alloc] init]; if(item.mode == SBODOInsert) [service pushInsert:item.entity callback:(SBODataFetchCallback *)self]; else if(item.mode == SBODOUpdate) [service pushUpdate:item.entity serverId:item.serverId callback:(SBODataFetchCallback *)self]; else if(item.mode == SBODODelete) [service pushDelete:item.entity serverId:item.serverId callback:(SBODataFetchCallback *)self]; // we now need to wait for something to happen... } When an OData change operation succeeds, the odataFetchOk method will be called on SBSync. We need to do something similar now in the callback depending on the op code as we did in SBODataServiceProxy—specifically, if we receive an OPCODE_ODATACHANGE notification, we need to increment the workItemIndex and call processWorkItems. The logic of processWorkItems dictates whether to run getLatest or do the next in the queue. Here’s the revised implementation of odataFetchOk: // Modify odataFetchOk method in SBSync.m… -(void)odataFetchOk:(SBEntityXmlBucket *)entities opCode:(int)theOpCode { if(theOpCode == OPCODE_ODATAFETCHALL) { // mode? if(self.mode == SBSMPushChanges) [self receiveServerItemsForPushChanges:entities]; else if(self.mode == SBSMGetLatest) [self receiveServerItemsForGetLatest:entities]; else @throw [NSException exceptionWithName:[[self class] description] reason:@""Mode was unhandled"" userInfo:nil]; } 425 CHAPTER 11 ■ IOS: PUSHING CHANGES BACK TO THE SERVER else if(theOpCode == OPCODE_ODATACHANGE) { // fire the next one in the queue... self.workItemIndex++; [self processWorkItems]; } else @throw [NSException exceptionWithName:[[self class] description] reason:@""Operation code was unhandled"" userInfo:nil]; } We’re now at a point where we can run the application and successfully synchronize some changes up to the server. Figure 11-18 illustrates a change to the text of my Topaz Filer bookmark example being propagated all the way up to the server and back down again into the generic web application, the source code to which can be downloaded from the web site. In this chapter, we have completed the work to make our Six Bookmarks application fully functional. We can now synchronize our bookmarks with the server and present a user interface for modification. C H A P T E R 1 2 ■ ■ ■ iOS: MonoTouch In this “bonus” iOS chapter, we’re going to take a quick look at MonoTouch. Mono is an open-source project led by Novell to—put simplistically—port the .NET Framework and toolset over to other platforms. MonoTouch is an extension of Mono that essentially “.NET-ifies” Cocoa Touch. You get all of the Cocoa Touch classes exposed as .NET managed classes. You get garbage collection and you get the C# language. It makes developing iOS applications a lot easier.There are two reasons MonoTouch is an “also-ran” in this book, rather than a main feature. In the first instance, this book is about achieving common tasks natively and directly on the platform of choice."
1,"Explain why if we create our view interface as ILogonView, we’ll create a controller called LogonController and have this extend Controller<ILogonView>","All MVC-like patterns call for representation of the view via an interface. This is because one of the basic tenets of MVC-like patterns is to remove dependence between the controller and view. (Practically, this is done for ease of maintenance and unit testing, although sometimes the more “academic” pitch is that you can create different views and reuse the same controllers and models.) Thus, whenever we 79 CHAPTER 5 ■ ANDROID: BUILDING THE LOGON FORM AND CONSUMING REST SERVICES create an activity, we’re going to create a view interface for it that exposes out the data we want from the view. Specifically in this case, it’s the username, password, and “remember me” values.We’re going to build our controller using generics. Hence,if we create our view interface as ILogonView, we’ll create a controller called LogonController and have this extend Controller<ILogonView>.","In the first instance, because we know that from time to time we’re going to need a context, we’ll create an interface called IContextSource that returns a concrete Context object. What we’ll also do is create an interface called IController that extends this IContextSource interface and also adds the ability to return an activity. Figure 5-6 illustrates. In the second instance, we need to bind the controllers and views together, which is a touch more complicated.All MVC-like patterns call for representation of the view via an interface. This is because one of the basic tenets of MVC-like patterns is to remove dependence between the controller and view. (Practically, this is done for ease of maintenance and unit testing, although sometimes the more “academic” pitch is that you can create different views and reuse the same controllers and models.) Thus, whenever we 79 CHAPTER 5 ■ ANDROID: BUILDING THE LOGON FORM AND CONSUMING REST SERVICES create an activity, we’re going to create a view interface for it that exposes out the data we want from the view. Specifically in this case, it’s the username, password, and “remember me” values.We’re going to build our controller using generics. Therefore, if we create our view interface as ILogonView, we’ll create a controller called LogonController and have this extend Controller<ILogonView>.This will give our controller a nice, strongly-typed representation of the view for internal consumption."
2,"Explain why if you change that table’s structure over time, you can reuse the code that builds the SQL statement to build the new table, all without you having to do too much work","The reason for this is that my approach is to optimize the development process and minimize the hassle of maintenance as opposed to build an application that’s blazingly fast in production. Most people work on small projects with a small set of users that’s easily served by run-of-the-mill hardware, but our community tends to encourage people to design applications that are ultra-high-performance and ultra-scalable. Most of the time, “you ain’t gonna need it.” What good quality metadata does for you is that it allows for code that is flexible and adapts to changes within the application. For example, you may have a need to create a database table when an application starts. With good metadata, you can dynamically build the SQL statement to create the table. Hence,if you change that table’s structure over time, you can reuse the code that builds the SQL statement to build the new table, all without you having to do too much work.","For your information, I am the maintainer of an open-source project called BootFX (www.bootfx.com/). The project is an application framework for .NET that has been under development since 2002. The ORM design that we’re going to use in this book is based on BootFX, although it will be a heavily cut-down version. I want to start by talking about “metadata.” In my opinion, the quality of any ORM tool, or any data access layer, (DAL) lives or dies by its metadata. I would go so far as to say it’s better to have an ORM implementation with excellent metadata that’s quite slow than it is to have an ORM implementation with poor metadata that’s quite fast.The reason for this is that my approach is to optimize the development process and minimize the hassle of maintenance as opposed to build an application that’s blazingly fast in production. Most people work on small projects with a small set of users that’s easily served by run-of-the-mill hardware, but our community tends to encourage people to design applications that are ultra-high-performance and ultra-scalable. Most of the time, “you ain’t gonna need it.” What good quality metadata does for you is that it allows for code that is flexible and adapts to changes within the application. For example, you may have a need to create a database table when an application starts. With good metadata, you can dynamically build the SQL statement to create the table.Thus, if you change that table’s structure over time, you can reuse the code that builds the SQL statement to build the new table, all without you having to do too much work. CHAPTER 3 ■ APPLICATION ARCHITECTURE AND FUNCTIONAL SPECIFICATION The metadata system that I’m going to present is modeled on the excellent type metadata system in .NET. In .NET you have a System.Type object that represents—for example—a class in your application.That Type instance can be used to reflect against the methods, properties, events, fields, etc. of that type."
3,Explain why EntityType will contain a collection of EntityField instances,"In our projects, we’re going to create a class called EntityType, which holds a collection of fields on a table. EntityType will map one-to-one with a database table. (In the more fully-featured BootFX, EntityType holds information on relationships, indexes, constraints, etc.) Hence,EntityType will contain a collection of EntityField instances.","That Type instance can be used to reflect against the methods, properties, events, fields, etc. of that type.In our projects, we’re going to create a class called EntityType, which holds a collection of fields on a table. EntityType will map one-to-one with a database table. (In the more fully-featured BootFX, EntityType holds information on relationships, indexes, constraints, etc.) Thus, EntityType will contain a collection of EntityField instances. us—it will hold two names for each item. The reason for this is that oftentimes in ORM you are inheriting someone else’s database schema, and you may want to abstract out naming conventions that are hard to work with (for example, TBL_CUST vs. Customer). Thus EntityItem will include a “native name” (via the NativeName property) and a “programmatic name” (via the Name property). specifically the data type, size, and an indication as to whether it’s a key field. Figure 3-5 shows a UML static structure sketch that shows these fields in play. Again, to reiterate the point, what this structure lets us do is very easily write code that builds dynamic SQL statements. For example, if we want to build a SELECT statement, we know the native name of the table, we know the fields on the table, and we know the name of each field, and from that we can build up our SELECT. (We can also add WHERE clauses to constrain the select, which we’ll go into later.) Now that you have an idea of how the metadata system is put together, let’s look at how rows are represented in memory. An EntityType is a one-to-one mapping with a database table. An Entity is a representation of a row on the entity. Each strongly-typed entity has fields that map to the columns on the database. This is where the “object-relational mapping” comes in—we have an object, and we’re mapping it to a relational database.For example, we might have a class called Customer that extends Entity. Customer might then have properties CustomerId, FirstName, LastName, and Email that map to the columns on the underlying table. CHAPTER 3 ■ APPLICATION ARCHITECTURE AND FUNCTIONAL SPECIFICATION When an entity is hydrated from a row in the database, the various field-mapped properties will be populated. This allows you to do code like this: foreach(Customer customer in Customer.GetAll()) Console.WriteLine(customer.Email); Internally within the entity, what happens is that each entity discovers its EntityType instance, looks at the number of fields and creates “slots” within it. So, if you have four fields, you will end up with a “slots” array that is four items in size. The properties then—simplistically—get or set values from the slots."
4,"Explain why when we want to call the “logon” method on the API service, we’ll create an ApiService class and call the Logon method","What I’ve wanted to do with the architecture of the way we deal with these services is try to get to a point where we get some of the wins of SOAP, but still have a really easy web service in the background. Hence,when we want to call the “logon” method on the API service, we’ll create an ApiService class and call the Logon method.","Readers who have used SOAP web services on the Microsoft stack before will be familiar with how easy it is to code against. If you haven’t, what happens is that Visual Studio creates a proxy class that looks like the service you are trying to call. Thus if you have a method exposed by a SOAP web service called HelloWorld that takes a string and returns a string, you can access it like this: HelloWorldWs ws = new HelloWorldWs(); string result = ws.HelloWorld(""Bob""); Console.WriteLine(result); The huge “win” with this approach is that it’s dead easy. The huge “loss,” and why it hasn’t really caught on, is that SOAP puts a ton of magic in the way that makes cross-platform communication too difficult. Over the ten or so years since SOAP was released, it’s been overtaken by web services that are constructed in a “here’s an XML document, can I have an XML document back?” way, with the XML going each way (we hope) as easily as possible.What I’ve wanted to do with the architecture of the way we deal with these services is try to get to a point where we get some of the wins of SOAP, but still have a really easy web service in the background.Thus, when we want to call the “logon” method on the API service, we’ll create an ApiService class and call the Logon method. Packaging up the request and error handling will all be dealt with by base classes. CHAPTER 3 ■ APPLICATION ARCHITECTURE AND FUNCTIONAL SPECIFICATION Specifically, we’ll build ServiceProxy, RestServiceProxy, and ODataServiceProxy base classes. the OData service. ApiService, UsersService, and BookmarksService will all provide specific implementations. Figure 3-8 illustrates. I’m not going to go into too much more detail here on this—when we build the code in the specific Android and iOS implementations, there’s plenty more detail. The important fact from this chapter to take away is that we want to make calling the services as easy and as natural as possible. In this section, we’ll look at each of the major things that we wish to achieve and state the technology that we’re going to use in each case.With regards to the HTML application, in this book’s sister book, where we go through this (remember you can download the code from http://code.multimobiledevelopment.com/ regardless of whether you own the book), we build an ASP.NET-based web site. Therefore the details in this section related to HTML discuss the .NET classes that you need to use. You can, of course, build mobile web applications using any platform. CHAPTER 3 ■ APPLICATION ARCHITECTURE AND FUNCTIONAL SPECIFICATION Core Toolset Table 3.1 documents the code toolset used for each platform. Android Eclipse, available on Mac, Windows, or Linux with the “Android ADT” plugin providing extra functionality within Eclipse (http://developer. iOS Xcode, available only on Mac Windows Phone Visual Studio 2010, available only on Windows Windows Mobile Visual Studio 2008, available only on Windows BlackBerry Eclipse, available on Mac, Windows, or Linux with the “BlackBerry Java Plug-in for Eclipse” providing extra functionality within Eclipse (http:// na.blackberry.com/eng/developers/javaappdev/javaplugin.jsp) HTML via ASP.NET web site ASP.NET via Visual Studio (Mono would also suffice, although in this chapter we’re using Visual Studio.) Issue HTTP Requests This applies to calling the Six Bookmarks proprietary RESTful services, downloading OData data, and pushing changes over OData. Table 3.2 lists the technology in each case. Android Apache HTTP Client library (http://hc.apache.org/ httpcomponents-client/) org.apache.http.* iOS Cocoa Touch NSConnection class and related types Windows Phone System.Net.HttpWebRequest and related classes for ad hoc requests—see the following for OData requests. System.Net.HttpWebRequest and related classes BlackBerry javax.microedition.io.Connector class and related classes HTML via ASP.NET web site System.Net.HttpWebRequest and related classes 31 CHAPTER 3 ■ APPLICATION ARCHITECTURE AND FUNCTIONAL SPECIFICATION Read XML Document (Including Reading OData Results) Generally speaking, there are two ways of reading an XML document—loading the entire thing into a document object model (DOM) tree and querying it as an object-hierarchy, or using a parser that is able to start at the top and read through the document, gathering data as it goes. Table 3.3 lists the technology in each case. Android DOM-based approach using standard Java implementation org.w3c.dom.* iOS Forward-only reader/parser using NSXMLParser Windows Phone DOM-based approach using System.X ml.Linq.XDocument for RESTful services, Visual Studio proxy class for OData Windows Mobile DOM-based approach using System.Xml.XmlDocument BlackBerry DOM-based approach using standard Java implementation org.w3c.dom.* HTML via ASP.NET web site DOM-based approach using System.Xml.XmlDocument Write an XML Document Like reading an XML document, you can write an XML document either by creating a DOM tree or by writing elements in turn programmatically. Table 3.4 lists the technology in each case. Android Writer approach using XML Pull library and org.xmlpull.v1.XmlSerializer iOS Writer approach using L Li bx ml2 library via native C-style API Windows Phone DOM-based approach using System.X ml.Linq.XDocument (However, we will not see this in the book, as Windows Phone creates a proxy for talking to OData services that hides this from us.) Windows Mobile DOM-based approach using System.Xml.XmlDocument BlackBerry Writer approach using XML Pull library and org.xmlpull.v1.XmlSerializer HTML via ASP.NET DOM-based approach using System.Xml.XmlDocument web site 32 CHAPTER 3 ■ APPLICATION ARCHITECTURE AND FUNCTIONAL SPECIFICATION Maintain a Local Store SQLite is available on all of the platforms apart from Windows Phone, which gives us a great opportunity for a common implementation. A relational store makes the most sense for this book on the principle that proper, real-world applications would likely need a relational store. Our actual requirements for Six Bookmarks is that we’re going to have only one table with a small number of rows in it, and practically, if that were a real-world requirement, storing the bookmarks in an XML file would likely make more sense. Android Managed API over SQLite via android.database.sqlite. iOS Direct access to SQLite via native C-style API Windows Phone No relational database available—will store XML files on disk Windows Mobile Managed API over SQLCE via System.Data.SqlServerCe. BlackBerry Managed API over SQLite via net.rim.device.api.database.Database and related types HTML via ASP.NET web site Not needed (However, if server-side storage is needed, a relational database such as SQL Server or MySQL fits the bill.) ■NOTE As a short rant, the fact that Windows Phone is coming to market initially without a relational database is shocking, especially as SQL Server Compact has been around for well over a decade. It would be excellent if Microsoft decided to bake SQLite into the platform like the other vendors have done. In this chapter, we have taken an in-depth look at the application that we intend to build, discussed in some detail the object-relational mapping approach that we’re going to take with local data storage, discussed the network communications and approach and gone through on each device how we intend to perform common activities. Download from Wow! eBook <www.wowebook.com> C H A P T E R 4 ■ ■ ■ Android: Installing the Toolset Now that we have taken an in-depth look at how to build a device-agnostic, web-based application, we can start looking at building native applications for the devices that we’ll see in this book. We’re going to start with Android, and in this chapter, we’ll learn about how to install the toolset."
5,Explain why if you have a TextView (i,"fill_parent directs the control to size the related element to the container. For LinearLayout, the container is the client area available on the screen (i.e., the physical device screen minus the status bar area). wrap_content directs the control to size the related element to the size of the content. Hence,if you have a TextView (i.","If you look at the logon.xml file that we already have, you’ll find it contains something like the following XML. (When you open the file, it’ll open in design mode—click the XML tab at the bottom of the view to show the XML.) 76 CHAPTER 5 ■ ANDROID: BUILDING THE LOGON FORM AND CONSUMING REST SERVICES <?xml version=""1.0"" encoding=""utf-8""?> <LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android"" android:orientation=""vertical"" android:layout_width=""fill_parent"" android:layout_height=""fill_parent"" > <TextView android:layout_width=""fill_parent"" android:layout_height=""wrap_content"" android:text=""@string/hello"" /> </LinearLayout> I want to talk initially about the namespace. We talk more about namespaces in Chapter 9, but for now, notice how all of the elements are prefixed with android: and hence refer to the Android namespace. I personally find that this adds a lot of unnecessary noise to the XML, and so I usually go through the file and rename android: to a:, like so: <?xml version=""1.0"" encoding=""utf-8""?> <LinearLayout xmlns:a=""http://schemas.android.com/apk/res/android"" a:orientation=""vertical"" a:layout_width=""fill_parent"" a:layout_height=""fill_parent"" > <TextView a:layout_width=""fill_parent"" a:layout_height=""wrap_content"" a:text=""@string/hello"" /> </LinearLayout> The layout_width and layout_height elements are the most important attributes in this file, as these tell you how the control will be fitted to the container, and it’s usually getting this right that causes the most frustration in building the layouts.fill_parent directs the control to size the related element to the container. For LinearLayout, the container is the client area available on the screen (i.e., the physical device screen minus the status bar area). wrap_content directs the control to size the related element to the size of the content. Thus, if you have a TextView (i.e., “label”) element and size the width to the parent and the height to the content, you’ll end up with a label as wide as the screen and as tall as the text contained within.If you refer back to Figure 5-4, we have one label for a blurb, one label for the username prompt, one textbox for the username, another label for the password prompt, one textbox for the password, one checkbox, and a button. All of these are configured to size their width to the parent and height to their content. Here’s the XML for the logon.xml form layout: <?xml version=""1.0"" encoding=""utf-8""?> <LinearLayout xmlns:a=""http://schemas.android.com/apk/res/android"" a:layout_width= ""fill_parent"" a:layout_height=""fill_parent"" a:orientation=""vertical""> 77 CHAPTER 5 ■ ANDROID: BUILDING THE LOGON FORM AND CONSUMING REST SERVICES <TextView a:text=""Welcome to Six Bookmarks. Enter your logon information to continue. ""web"" a:layout_width=""fill_parent"" a:layout_height=""wrap_content"" /> <TextView a:text=""Username:"" a:layout_width=""wrap_content"" a:layout_height= ""wrap_content"" /> <EditText a:id=""@+id/textUsername"" a:singleLine=""true"" a:layout_width=""fill_parent"" a:layout_height=""wrap_content"" /> <TextView a:text=""Password:"" a:layout_width=""wrap_content"" a:layout_height= ""wrap_content"" /> <EditText a:id=""@+id/textPassword"" a:singleLine=""true"" a:password=""true"" a:layout_width= ""fill_parent"" a:layout_height=""wrap_content"" /> <CheckBox a:text=""Remember me"" a:id=""@+id/checkRememberMe"" a:checked=""true"" a:layout_width=""wrap_content"" a:layout_height=""wrap_content"" /> <Button a:text=""Logon"" a:id=""@+id/buttonLogon"" a:layout_width=""fill_parent"" a:layout_height=""wrap_content"" /> </LinearLayout> Once you have the layout defined, it’s easy enough to see how it works in landscape or portrait orientation by using the Layout sub-tab on the editor window. At the top of the Layout view, you’ll see a drop-down list labeled Config. You can change this between portrait and landscape views. Figure 5-5 illustrates the form in landscape view. Notice how in this mode, the button is rendered off the bottom of the screen. 78 CHAPTER 5 ■ ANDROID: BUILDING THE LOGON FORM AND CONSUMING REST SERVICES Model/View/Controller When we come to do the chapters on iPhone, the recommended paradigm for building the user interface is to split the user interface and code to drive the user interface apart. There are a number of names and variations of this pattern, but a commonly known one is Model/View/Controller, or MVC. In MVC, you have separate classes for data, separate classes for views, and separate classes for code that binds the two together (the controller). Android does not mandate use of MVC, but because a) I think it’s more sensible and b) the others do mandate some form of split, I’m going to recommend that we do, too."
6,"Explain why if we have an activity, we have a context","We’re going to designate our Logon class as the view and create another class called LogonController as the controller. For the logon form, there isn’t really a model, but in the next chapter where we start working with bookmarks, the classes that hold the bookmark will be considered to be the model. When our Android application is started, a “context” is created that contains global state to support the running of that application. This context is held in a class called android.content.Context, and the activities extend this class. Hence,if we have an activity, we have a context.","If you refer back to Figure 5-4, we have one label for a blurb, one label for the username prompt, one textbox for the username, another label for the password prompt, one textbox for the password, one checkbox, and a button. All of these are configured to size their width to the parent and height to their content. Here’s the XML for the logon.xml form layout: <?xml version=""1.0"" encoding=""utf-8""?> <LinearLayout xmlns:a=""http://schemas.android.com/apk/res/android"" a:layout_width= ""fill_parent"" a:layout_height=""fill_parent"" a:orientation=""vertical""> 77 CHAPTER 5 ■ ANDROID: BUILDING THE LOGON FORM AND CONSUMING REST SERVICES <TextView a:text=""Welcome to Six Bookmarks. Enter your logon information to continue. ""web"" a:layout_width=""fill_parent"" a:layout_height=""wrap_content"" /> <TextView a:text=""Username:"" a:layout_width=""wrap_content"" a:layout_height= ""wrap_content"" /> <EditText a:id=""@+id/textUsername"" a:singleLine=""true"" a:layout_width=""fill_parent"" a:layout_height=""wrap_content"" /> <TextView a:text=""Password:"" a:layout_width=""wrap_content"" a:layout_height= ""wrap_content"" /> <EditText a:id=""@+id/textPassword"" a:singleLine=""true"" a:password=""true"" a:layout_width= ""fill_parent"" a:layout_height=""wrap_content"" /> <CheckBox a:text=""Remember me"" a:id=""@+id/checkRememberMe"" a:checked=""true"" a:layout_width=""wrap_content"" a:layout_height=""wrap_content"" /> <Button a:text=""Logon"" a:id=""@+id/buttonLogon"" a:layout_width=""fill_parent"" a:layout_height=""wrap_content"" /> </LinearLayout> Once you have the layout defined, it’s easy enough to see how it works in landscape or portrait orientation by using the Layout sub-tab on the editor window. At the top of the Layout view, you’ll see a drop-down list labeled Config. You can change this between portrait and landscape views. Figure 5-5 illustrates the form in landscape view. Notice how in this mode, the button is rendered off the bottom of the screen. 78 CHAPTER 5 ■ ANDROID: BUILDING THE LOGON FORM AND CONSUMING REST SERVICES Model/View/Controller When we come to do the chapters on iPhone, the recommended paradigm for building the user interface is to split the user interface and code to drive the user interface apart. There are a number of names and variations of this pattern, but a commonly known one is Model/View/Controller, or MVC. In MVC, you have separate classes for data, separate classes for views, and separate classes for code that binds the two together (the controller). Android does not mandate use of MVC, but because a) I think it’s more sensible and b) the others do mandate some form of split, I’m going to recommend that we do, too.We’re going to designate our Logon class as the view and create another class called LogonController as the controller. For the logon form, there isn’t really a model, but in the next chapter where we start working with bookmarks, the classes that hold the bookmark will be considered to be the model. When our Android application is started, a “context” is created that contains global state to support the running of that application. This context is held in a class called android.content.Context, and the activities extend this class. Thus, if we have an activity, we have a context.In the first instance, because we know that from time to time we’re going to need a context, we’ll create an interface called IContextSource that returns a concrete Context object. What we’ll also do is create an interface called IController that extends this IContextSource interface and also adds the ability to return an activity. Figure 5-6 illustrates. In the second instance, we need to bind the controllers and views together, which is a touch more complicated."
7,"Explain why whenever we 79 CHAPTER 5 ■ ANDROID: BUILDING THE LOGON FORM AND CONSUMING REST SERVICES create an activity, we’re going to create a view interface for it that exposes out the data we want from the view","All MVC-like patterns call for representation of the view via an interface. This is because one of the basic tenets of MVC-like patterns is to remove dependence between the controller and view. (Practically, this is done for ease of maintenance and unit testing, although sometimes the more “academic” pitch is that you can create different views and reuse the same controllers and models.) Hence,whenever we 79 CHAPTER 5 ■ ANDROID: BUILDING THE LOGON FORM AND CONSUMING REST SERVICES create an activity, we’re going to create a view interface for it that exposes out the data we want from the view.","In the first instance, because we know that from time to time we’re going to need a context, we’ll create an interface called IContextSource that returns a concrete Context object. What we’ll also do is create an interface called IController that extends this IContextSource interface and also adds the ability to return an activity. Figure 5-6 illustrates. In the second instance, we need to bind the controllers and views together, which is a touch more complicated.All MVC-like patterns call for representation of the view via an interface. This is because one of the basic tenets of MVC-like patterns is to remove dependence between the controller and view. (Practically, this is done for ease of maintenance and unit testing, although sometimes the more “academic” pitch is that you can create different views and reuse the same controllers and models.) Thus, whenever we 79 CHAPTER 5 ■ ANDROID: BUILDING THE LOGON FORM AND CONSUMING REST SERVICES create an activity, we’re going to create a view interface for it that exposes out the data we want from the view. Specifically in this case, it’s the username, password, and “remember me” values.We’re going to build our controller using generics. Therefore, if we create our view interface as ILogonView, we’ll create a controller called LogonController and have this extend Controller<ILogonView>."
8,"Explain why when we add fields, the first will have ordinal 0, the second ordinal 1, and so on","In addition, we’re going to add a method to EntityType called AddField. This will be used to programmatically define the fields available on an entity type. This AddField method will look at the size of the fields collection and use this size as the ordinal for the field. Hence,when we add fields, the first will have ordinal 0, the second ordinal 1, and so on.","So that we can effectively work with entities, we need EntityType to be able to instantiate instances of individual entities and collections of entities. In this example, we’re going to have only one entity— Bookmark. In any real world application, you’re likely to have many entitity types. We’ll hold references to the relevant Java types so that we can create the object instances that we want programmatically. (A Java type is synonymous to a .NET type. Both provide runtime access to the type metadata system.) Our motivation for this arrangement is so that we can say to framework code “give me a list of bookmarks,” and the framework code itself will be able to create an appropriate collection type and individual entities.In addition, we’re going to add a method to EntityType called AddField. This will be used to programmatically define the fields available on an entity type. This AddField method will look at the size of the fields collection and use this size as the ordinal for the field. Thus, when we add fields, the first will have ordinal 0, the second ordinal 1, and so on. Having field ordinals will come in handy when getting or setting in-memory values against the entity.Here’s the listing for EntityType that looks after storing the instance and collection types, and storing the list of fields. It, too, extends EntityItem—note how when we create an instance, we’ll call the base class and set the programmatic name to the name of the Java class, and the native name to whatever the user specifies. import java.lang.reflect.*; import java.util.*; public class EntityType extends EntityItem { private ArrayList<EntityField> _fields = new ArrayList<EntityField>(); private Class _instanceType = null; private Class _collectionType = null; public EntityType(Class instanceType, Class collectionType, String nativeName) { super(instanceType.getName(), nativeName); _instanceType = instanceType; _collectionType = collectionType; } public ArrayList<EntityField> getFields() { return _fields; } public EntityField AddField(String name, String nativeName, DataType type, int size) { EntityField field = new EntityField(name, nativeName, type, size, _fields.size()); _fields.add(field); 97 CHAPTER 6 ■ ANDROID: AN ORM LAYER ON SQLITE // return... return field; } public Class getInstanceType() { return _instanceType; } public Class getCollectionType() { return _collectionType; } public Entity CreateInstance() throws Exception { return (Entity)getInstanceType().newInstance(); } public ArrayList<Entity> CreateCollectionInstance() throws Exception { return (ArrayList<Entity>)getCollectionType().newInstance(); } } We’ve assumed that entities will always have a base class of Entity (which we’ll build shortly) and also be of type ArrayList. (Entity is going to hold an instance of a row in a table in the database.) Also on an entity type, we’re going to need to be able to find a field with a specific name, find the key fields, or determine whether a field with a specified name actually exists. (This latter one is used for populating entities from data received over XML where the XML may reference fields that we don’t know about.) Here are the three methods that also need to be added to EntityType: // Add to EntityType.java public EntityField GetField(String name, boolean throwIfNotFound) throws Exception { for(EntityField field : _fields) { if(field.getName().compareToIgnoreCase(name) == 0) return field; } // throw... if(throwIfNotFound) throw new Exception(String.format(""Failed to find a field with name '%s'."", name)); 98 CHAPTER 6 ■ ANDROID: AN ORM LAYER ON SQLITE else return null; } public EntityField GetKeyField() throws Exception { for(EntityField field : _fields) { if(field.getIsKey()) return field; } // throw... throw new Exception(""Failed to find a key field.""); } public boolean IsField(String name) throws Exception { EntityField field = this.GetField(name, false); if(field != null) return true; else return false; } Another method that we’ll need on EntityType is one that returns the short name of a class. The getName method on a regular Java Class type returns a fully-qualified name, including the package, e.g., com.AmxMobile.SixBookmarks.Database.Bookmark. This method—which needs to be added to EntityType—returns just the last part: // Add to EntityType.java public String getShortName() { String name = getName(); int index = name.lastIndexOf((char)'.'); return name.substring(index + 1); } Next, recall that the other function EntityType needs is the ability to hold a register of the available entity types. We’ll do this by creating a static hashtable on EntityType and methods called RegisterEntityType and GetEntityType. public class EntityType extends EntityItem { private static Hashtable<String, EntityType> _entityTypes = new Hashtable<String, EntityType>(); 99 CHAPTER 6 ■ ANDROID: AN ORM LAYER ON SQLITE // code omitted for brevity… public static void RegisterEntityType(EntityType entityType) { _entityTypes.put(entityType.getInstanceType().getName(), entityType); } public static EntityType GetEntityType(Class type) throws Exception { String name = type.getName(); for(String key : _entityTypes.keySet()) { if(key.compareTo(name) == 0) return _entityTypes.get(key); } // throw... throw new Exception(String.format(""Failed to get entity type for '%s'."", type)); } // code omitted for brevity… } Creating the Basic “Entity” Class We need a way of programmatically registering the entity type for the bookmark entity. One way to do this is to create a global “runtime” class that is used to boot up and tear down the application. We’ll add one of these to our project called SixBookmarksRuntime; however, we won’t build this until a little later."
9,"Explain why to move from the logon form to our new navigator form, we have to create an intent to show the navigator form and then run that intent","Android as a system is made up of activities, and activities are bundled together within applications.For example, you may have activities for showing a logon form, or showing a web page, or making a phone call. Android works on the principle that to move between activities you have to create “intents”—e.g., “I intend to show this web page” or “I intend to show this application-specific form.” Hence,to move from the logon form to our new navigator form, we have to create an intent to show the navigator form and then run that intent.","The activity itself (at this point) has the dual purpose of wiring up the nine buttons and deferring to the controller for processing, plus implementing the two methods on INavigatorView so that the controller can ask the view to update the buttons. In the next section, we’ll make it display our mock bookmarks. package com.amxMobile.SixBookmarks; import com.amxMobile.SixBookmarks.Runtime.*; import android.app.Activity; import android.os.Bundle; import android.view.*; import android.view.View.OnClickListener; import android.widget.*; public class Navigator extends Activity implements OnClickListener, INavigatorView { private NavigatorController Controller; public Navigator() { this.Controller = new NavigatorController(this); } /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.navigator); // wire up the buttons... findViewById(R.id.buttonNavigate1).setOnClickListener(this); findViewById(R.id.buttonNavigate2).setOnClickListener(this); findViewById(R.id.buttonNavigate3).setOnClickListener(this); findViewById(R.id.buttonNavigate4).setOnClickListener(this); findViewById(R.id.buttonNavigate5).setOnClickListener(this); findViewById(R.id.buttonNavigate6).setOnClickListener(this); findViewById(R.id.buttonConfigure).setOnClickListener(this); findViewById(R.id.buttonLogoff).setOnClickListener(this); findViewById(R.id.buttonAbout).setOnClickListener(this); } 115 CHAPTER 6 ■ ANDROID: AN ORM LAYER ON SQLITE public void onClick(View v) { if(v.getId() == R.id.buttonConfigure) this.Controller.HandleConfigure(); else if(v.getId() == R.id.buttonLogoff) this.Controller.HandleLogoff(); else if(v.getId() == R.id.buttonAbout) this.Controller.HandleAbout(); else if(v.getId() == R.id.buttonNavigate1) this.Controller.HandleNavigate(0); else if(v.getId() == R.id.buttonNavigate2) this.Controller.HandleNavigate(1); else if(v.getId() == R.id.buttonNavigate3) this.Controller.HandleNavigate(2); else if(v.getId() == R.id.buttonNavigate4) this.Controller.HandleNavigate(3); else if(v.getId() == R.id.buttonNavigate5) this.Controller.HandleNavigate(4); else if(v.getId() == R.id.buttonNavigate6) this.Controller.HandleNavigate(5); } private Button GetBookmarkButton(int ordinal) throws Exception { int id = 0; if(ordinal == 0) id = R.id.buttonNavigate1; else if(ordinal == 1) id = R.id.buttonNavigate2; else if(ordinal == 2) id = R.id.buttonNavigate3; else if(ordinal == 3) id = R.id.buttonNavigate4; else if(ordinal == 4) id = R.id.buttonNavigate5; else if(ordinal == 5) id = R.id.buttonNavigate6; else throw new Exception(String.format(""'%d' is an invalid ordinal."", ordinal)); // return... return (Button) this.findViewById(id); } 116 CHAPTER 6 ■ ANDROID: AN ORM LAYER ON SQLITE public void ResetBookmarkButton(int ordinal) throws Exception { Button button = GetBookmarkButton(ordinal); button.setText(""...""); } public void ConfigureBookmarkButton(int ordinal, String name) throws Exception { Button button = GetBookmarkButton(ordinal); button.setText(name); } } That’s it. Now all we have to do is create and display the mock bookmarks. The NavigatorController will be responsible for taking a set of bookmarks and instructing the view to update itself. Within its private instance state, the controller will also keep track of the URLs associated with each button ordinal. These URLs will be null in instances where no bookmark is defined for the ordinal, or the actual URL to show on click. These will be held in a private field with a private property getter; as per this listing: // Add to NavigatorController.java public class NavigatorController extends Controller<INavigatorView> { private String[] _urls = null; // code removed for brevity... private String[] getUrls() { return _urls; } // code removed for brevity... } We’ll add a method called ShowBookmarks that will update the view and also keep the data within _urls valid. When we call ShowBookmarks, we’ll reset the state of the six buttons, and then go through the bookmarks we were given, updating the appropriate ordinal as we go. Here’s the code: // Add to NavigatorController.java public void ShowBookmarks(BookmarkCollection bookmarks) throws Exception { // store the bookmarks collection... final int maxBookmarks = 6; _urls = new String[maxBookmarks]; 117 CHAPTER 6 ■ ANDROID: AN ORM LAYER ON SQLITE // reset the bookmarks... for(int index = 0; index < maxBookmarks; index++) ResetBookmark(index); // walk and set... for(Bookmark bookmark : bookmarks) ShowBookmark(bookmark); } private void ResetBookmark(int ordinal) throws Exception { // reset the view... getView().ResetBookmarkButton(ordinal); // reset the url... getUrls()[ordinal] = null; } private void ShowBookmark(Bookmark bookmark) throws Exception { int ordinal = bookmark.getOrdinal(); // set the view... getView().ConfigureBookmarkButton(ordinal, bookmark.getName()); // set the url... getUrls()[ordinal] = bookmark.getUrl(); } We’re now in a position to run the process. First, we need to add code to the Navigator class to instruct the controller to load: // Add to Navigator.java – modify the onCreate method… /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.navigator); // wire up the buttons... findViewById(R.id.buttonNavigate1).setOnClickListener(this); findViewById(R.id.buttonNavigate2).setOnClickListener(this); findViewById(R.id.buttonNavigate3).setOnClickListener(this); findViewById(R.id.buttonNavigate4).setOnClickListener(this); 118 CHAPTER 6 ■ ANDROID: AN ORM LAYER ON SQLITE findViewById(R.id.buttonNavigate5).setOnClickListener(this); findViewById(R.id.buttonNavigate6).setOnClickListener(this); findViewById(R.id.buttonConfigure).setOnClickListener(this); findViewById(R.id.buttonLogoff).setOnClickListener(this); findViewById(R.id.buttonAbout).setOnClickListener(this); // tell the controller to load... try { Controller.HandleLoad(); } catch(Exception ex) { MessageBox.Show(this, ex); } } In the Load method of the controller, we can then create and show the bookmarks. Here’s the code to replace the Load method that we stubbed earlier: // Add to NavigatorController.java – replace the existing Load method… public void HandleLoad() throws Exception { // create some fake bookmarks... BookmarkCollection bookmarks = new BookmarkCollection(); AddBookmark(bookmarks, "".NET 247"" , ""http://www.dotnet247.com/"", 0); AddBookmark(bookmarks, ""Apress"", ""http://www.apress.com/"", 1); // show the bookmarks... this.ShowBookmarks(bookmarks); } private void AddBookmark(BookmarkCollection bookmarks, String name, String url, int ordinal) throws Exception { // create... Bookmark bookmark = new Bookmark(); bookmark.setName(name); bookmark.setUrl(url); bookmark.setOrdinal(ordinal); // add... bookmarks.add(bookmark); } We’re almost there! The only thing that remains is to modify the logon form so that it will start the Navigator activity when a logon has been successful. CHAPTER 6 ■ ANDROID: AN ORM LAYER ON SQLITE Adding the Activity to the Manifest Before the activity can be used, it needs to be added to the manifest file. This is easily enough done. <manifest xmlns:android=""http://schemas.android.com/apk/res/android"" android:versionCode=""1"" android:versionName=""1.0"" package=""com.amxMobile.SixBookmarks""> <application android:icon=""@drawable/icon"" android:label=""@string/app_name""> <activity android:name="".Logon"" android:label=""@string/app_name""> <intent-filter> <action android:name=""android.intent.action.MAIN"" /> <category android:name=""android.intent.category.LAUNCHER"" /> </intent-filter> </activity> <activity android:name="".Navigator"" android:label=""@string/app_name""> <intent-filter> <action android:name=""android.intent.action.MAIN"" /> <category android:name=""android.intent.category.LAUNCHER"" /> </intent-filter> </activity> </application> <uses-permission android:name=""android.permission.INTERNET""></uses-permission> </manifest> In the next section, we’ll see how to refer to the activity and launch it from the LogonController class. This next bit we’re going to look at is a part of Android that I’m not particularly fond of, as I personally feel it’s a little complicated.Android as a system is made up of activities, and activities are bundled together within applications.For example, you may have activities for showing a logon form, or showing a web page, or making a phone call. Android works on the principle that to move between activities you have to create “intents”—e.g., “I intend to show this web page” or “I intend to show this application-specific form.” Thus, to move from the logon form to our new navigator form, we have to create an intent to show the navigator form and then run that intent. Android will then determine what needs to be done and then do it. CHAPTER 6 ■ ANDROID: AN ORM LAYER ON SQLITE On the LogonController (note, not NavigatorController), in DoLogon all we need to do is create an intent, refer to the navigator, and then ask the Logon activity to start it. Here’s the code that needs to be modified in LogonController: // Code to modify in LogonController.java.. private boolean DoLogon(String username, String password, boolean rememberMe) throws Exception { UsersService users = new UsersService(); LogonResponse response = users.Logon(username, password); // now what? if(response.getResult() == LogonResult.LogonOk) { // store the credentials? if(rememberMe) StoreCredentials(username, password); else ClearCredentials(); // create an intent and show the navigator... Intent newIntent = new Intent(getActivity(), Navigator.class); getActivity().startActivity(newIntent); // return... return true; } else { MessageBox.Show(this, response.getMessage()); return false; } } If you run the application now and log on (you’ll be automatically logged in if you’d previously selected “remember me”), you’ll see the two mock bookmarks, as shown in Figure 6-3. CHAPTER 6 ■ ANDROID: AN ORM LAYER ON SQLITE Figure 6-3. The application showing two fake bookmarks Wiring Up the Bookmarks Now that we’re this far, we should at least try and make our buttons do something! We can ask Android to open a web browser to the URL that we want by creating an intent bound to a URL. displays a message box indicating that it’s pending implementation. We can change this now to look at the URL associated with the chosen ordinal. If we have a URL, we’ll create an intent bound to that URL and ask Android to show it. If we do not have a URL, we’ll defer to the HandleConfigure method. This method will ultimately show the configuration form—we’ll build this in the next chapter. Here’s the code to change in NavigatorController: package com.amxMobile.SixBookmarks; import android.content.*; import android.net.*; import com.amxMobile.SixBookmarks.Database.*; import com.amxMobile.SixBookmarks.Runtime.*; public class NavigatorController extends Controller<INavigatorView> { // code removed for brevity… 122 CHAPTER 6 ■ ANDROID: AN ORM LAYER ON SQLITE // New implementation of HandleNavigate… public void HandleNavigate(int ordinal) { // get the url... String url = getUrls()[ordinal]; // did we actually click a null button? if(url == null || url.length() == 0) HandleConfigure(); else { // create an intent to show the URL... Intent myIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(url)); getActivity().startActivity(myIntent); } } } Now if you run the application, and click on one of the buttons, Android will show you the relevant URL. Figure 6-4 illustrates.Figure 6-4. The result of a successful navigation using Android’s built-in Web browser If you want, now that we know how to point the browser at URLs of our choosing, we can also wire up the HandleAbout method at this point. Here’s the code: 123 CHAPTER 6 ■ ANDROID: AN ORM LAYER ON SQLITE // Replace method in NavigatorController.java… public void HandleAbout() { Intent myIntent = new Intent(Intent.ACTION_VIEW, Uri.parse ("" http://www.multimobiledevelopment.com/"")); getActivity().startActivity(myIntent); } Building the “Sync” Class At this point we’ve covered a lot of ground. We have the foundation of an ORM system in place, we can create bookmark entities, and we can display them on the screen. In the remainder of this chapter, we’re going to see how we can download bookmarks from the online service, store them in a local SQLite database, and then read them back from the SQLite database for display on the screen. In the next chapter, we’re going to look at how the bookmarks can be modified and how changes can be pushed back up to the server. In the last chapter, we created a few classes, including ServiceProxy, ApiService, and LogonService, to communicate with the restful services at http://services.multimobiledevelopment.com/. In this section, we’re going to look at building BookmarksService, which is able to communicate with the Bookmarks OData service. We’ll also build the base ODataServiceProxy class to support the operations of BookmarksService."
10,"Explain why we need to walk the entity type fields, retrieve the value from the row, and set the value on the entity","LoadEntity has to create an entity instance and then populate it with values from the database.There is an assumption here that the columns defined in the filter’s statement include every field available on the entity type. On a more sophisticated ORM implementation, this may not be the case, but in our case it is. Hence,we need to walk the entity type fields, retrieve the value from the row, and set the value on the entity.","The purpose of SqlFilter is to retrieve values from the database based on the principle of constraining data down from the maximum possible set (all rows in a table) to the set that you want. It could be that the set you want is the maximum possible set (“get all”), a single row represented by a key value (“get by ID”), or any other set that you fancy. ExecuteNonQuery method to accept an ISqlStatementSource and then ultimately de-reference a real SqlStatement instance to run. We’ll do the same thing with our ExecuteEntityCollection, and we’ll also make SqlFilter implement ISqlStatementSource. this: SELECT BookmarkId, Name, Value, Ordinal from Bookmarks Here’s the code, including a helper method also called ExecuteEntityCollection that will defer to a DatabaseHelper instance for execution: 148 CHAPTER 6 ■ ANDROID: AN ORM LAYER ON SQLITE package com.amxMobile.SixBookmarks.Runtime; import java.util.*; import com.amxMobile.SixBookmarks.Entities.*; import android.database.*; import android.database.sqlite.*; public class SqlFilter implements ISqlStatementSource { private EntityType _entityType; public SqlFilter(Class type) throws Exception { this(EntityType.GetEntityType(type)); } public SqlFilter(EntityType et) { _entityType = et; } private EntityType getEntityType() { return _entityType; } public SqlStatement GetSqlStatement() { EntityType et = getEntityType(); SqlStatement sql = new SqlStatement(); StringBuilder builder = new StringBuilder(); // columns... builder.append(""SELECT ""); ArrayList<EntityField> fields = et.getFields(); for(int index = 0; index < fields.size(); index++) { if(index > 0) builder.append("", ""); builder.append(fields.get(index).getNativeName()); } // from... builder.append("" FROM ""); builder.append(et.getNativeName()); 149 CHAPTER 6 ■ ANDROID: AN ORM LAYER ON SQLITE // return... sql.setCommandText(builder.toString()); return sql; } public ArrayList ExecuteEntityCollection(IContextSource context) throws Exception { // shortcut method - defer to the helper... DatabaseHelper db = new DatabaseHelper(context); return db.ExecuteEntityCollection(this, getEntityType()); } } Executing the Entity Collection Now that we have a statement to run, we need to connect to the database and execute it. This will return back a forward-only cursor that we can iterate through creating entities as we go. // Add to DatabaseHelper.java public ArrayList<Entity> ExecuteEntityCollection(ISqlStatementSource sql, EntityType et) throws Exception { // get... SqlStatement realSql = sql.GetSqlStatement(); SQLiteDatabase db = getReadableDatabase(); Cursor c = null; try { // execute a cursor... ArrayList<Entity> results = et.CreateCollectionInstance(); // cursor... c = db.rawQuery(realSql.getCommandText(), null); while(c.moveToNext()) { // load... Entity entity = LoadEntity(c, et); results.add(entity); } // return... return results; } 150 CHAPTER 6 ■ ANDROID: AN ORM LAYER ON SQLITE finally { if(c != null) c.close(); if(db != null) db.close(); } } You can see there how this gets a real statement from the source object and opens a readable connection to the database. (We assume that the statement does not contain directives to change the data.) We can ask the entity type to return a collection instance, and once we have that, we can run the statement and return a cursor. Each iteration of the loop defers to LoadEntity, which we’ll build now.LoadEntity has to create an entity instance and then populate it with values from the database.There is an assumption here that the columns defined in the filter’s statement include every field available on the entity type. On a more sophisticated ORM implementation, this may not be the case, but in our case it is. Thus, we need to walk the entity type fields, retrieve the value from the row, and set the value on the entity. When we do this, we need to mark the call as having SetReason.Load. This flag tells the entity that the value has been loaded but not modified. If we were to call SaveChanges, nothing would happen—the ID field would be loaded, and hence it would not be new, no column would be modified, and hence the whole entity would be unchanged. (The entity has obviously not been deleted either, but we have not implemented that check, yet.) Here’s the code for LoadEntity: // Add to DatabaseHelper.java… private Entity LoadEntity(Cursor c, EntityType et) throws Exception { // create a new instance... Entity entity = et.CreateInstance(); // load data... for(EntityField field : et.getFields()) { DataType type = field.getDataType(); if(type == DataType.String) entity.SetValue(field, c.getString(field.getOrdinal()), SetReason.Load); else if(type == DataType.Int32) entity.SetValue(field, c.getInt(field.getOrdinal()), SetReason.Load); else throw new Exception(String.format(""Cannot handle '%s'."", field.getDataType())); } // return... return entity; } 151 CHAPTER 6 ■ ANDROID: AN ORM LAYER ON SQLITE Asking the Navigator Controller to Load the Real Bookmarks All that remains now is to modify the Load method of the navigator controller so that it loads the real bookmarks from the database rather than the fake ones we’ve been using up until now. Here’s the code: // Modify method in NavigatorController.java… public void Load() throws Exception { // select from the database... SqlFilter filter = new SqlFilter(Bookmark.class); ShowBookmarks((BookmarkCollection)filter.ExecuteEntityCollection(this)); } If we run the project, we now go end to end, and we’ll see the bookmarks get synchronized from the server and shown on the navigator. Figure 6-9 shows some sample results.Figure 6-9. Success! The application shows the bookmarks selected from the database after downloading from the server ■NOTE The filter created in the Load method will return all bookmarks, even ones with the LocalDeleted value set to true. In the next chapter, we’ll change this method to exclude ones that have been deleted via configuration. CHAPTER 6 ■ ANDROID: AN ORM LAYER ON SQLITE Conclusion In this chapter, we have covered considerable ground in that we can now join activities together, call up to the OData service, store entities in our local database, and read them back. We also built a fully- functional (albeit slightly limited) object-relational mapping system complete with metadata subsystem."
11,"Explain why when we delete locally, we’ll “soft delete” rather than “hard delete” the item","We’re about to start building our “Configuration” window. One of the things this will allow the user to do is delete bookmarks. However, we cannot delete bookmarks from our local database because if we do not have an item locally, we don’t know that the server version is not in sync and needs to be deleted. Hence,when we delete locally, we’ll “soft delete” rather than “hard delete” the item.","I’ve found in the past that it’s more practical to design these classes by hiding the physical SqlConstraint objects away from the caller and adding methods to SqlFilter that actually add the constraints in. I’ve also found that it’s generally a good idea that when working with items that map down to the entity metadata subsystem, creating method overload takes the item’s name and a second overload that takes the related EntityField instance itself is also a good idea. Thus, we create one method that takes a field name and another that takes an EntityField instance. In addition, we also need to optionally provide the operator, assuming “equal to” in situations where an operator is not provided. Here’s the code: // Add field and methods to SqlFilter… package com.amxMobile.SixBookmarks.Runtime; public class SqlFilter implements ISqlStatementSource { private EntityType _entityType; private ArrayList<SqlConstraint> _constraints = new ArrayList<SqlConstraint>(); // code omitted for brevity... private ArrayList<SqlConstraint> getConstraints() { return _constraints; } public void AddConstraint(String name, Object value) throws Exception { EntityField field = getEntityType().GetField(name, true); AddConstraint(field, value); } public void AddConstraint(EntityField field, Object value) { getConstraints().add(new SqlFieldConstraint(field, value)); } public void AddConstraint(String name, SqlOperator op, Object value) throws Exception { EntityField field = getEntityType().GetField(name, true); AddConstraint(field, op, value); } 158 CHAPTER 7 ■ ANDROID: PUSHING CHANGES TO THE SERVER public void AddConstraint(EntityField field, SqlOperator op,Object value) { getConstraints().add(new SqlFieldConstraint(field, op, value)); } } Now that we can create and store constraints, we just need to modify the GetSqlStatement method to detect the existence of constraints and apply them. Here’s the modified version of GetSqlStatement: // Modify GetSqlStatement method within SqlFilter…public SqlStatement GetSqlStatement() throws Exception { SqlStatement sql = new SqlStatement(); StringBuilder builder = new StringBuilder(); // et... EntityType et = getEntityType(); // columns... builder.append(""SELECT ""); ArrayList<EntityField> fields = et.getFields(); for(int index = 0; index < fields.size(); index++) { if(index > 0) builder.append("", ""); builder.append(fields.get(index).getNativeName()); } // from... builder.append("" FROM ""); builder.append(et.getNativeName()); // where... ArrayList<SqlConstraint> constraints = getConstraints(); if(constraints.size() > 0) { builder.append("" WHERE ""); for(int index = 0; index < constraints.size(); index++) { if(index > 0) builder.append("" AND ""); constraints.get(index).Append(sql, builder); } } 159 CHAPTER 7 ■ ANDROID: PUSHING CHANGES TO THE SERVER // return... sql.setCommandText(builder.toString()); return sql; } In the last chapter, when we created our ExecuteEntityCollection method, we didn’t have any constraints; hence we did not have any parameters to pass in. What we need to do now is go back and revisit ExecuteEntityCollection, and in the part where we set up the query to run, we need to package up and pass in the variables. (Slightly sinisterly, if we forget to do this and have a query string that defines parameters, but do not pass in any parameters, SQLite quietly accepts the query and assumes the parameter values are all null.) More oddly, when we want to use a cursor to get values back, the parameter values all need to be passed in as strings, not the native type of the parameter value. Thus, we need a method that mangles the parameter values into strings. And here it is: // Add method to DatabaseHelper… private String[] MangleParameterValues(Object[] values) { String[] args = new String[values.length]; for(int index = 0; index < values.length; index++) args[index] = values[index].toString(); // return... return args; } When we create the cursor in ExecuteEntityCollection (the db.rawQuery call), we need to pass in the result of this. Here’s the modification required to ExecuteEntityCollection: public ArrayList<Entity> ExecuteEntityCollection(ISqlStatementSource sql, EntityType et) throws Exception { // get... SqlStatement realSql = sql.GetSqlStatement(); SQLiteDatabase db = getReadableDatabase(); Cursor c = null; try { // execute a cursor... ArrayList<Entity> results = et.CreateCollectionInstance(); // cursor... c = db.rawQuery(realSql.getCommandText(), MangleParameterValues(realSql.getParameterValues())); 160 CHAPTER 7 ■ ANDROID: PUSHING CHANGES TO THE SERVER while(c.moveToNext()) { // load... Entity entity = LoadEntity(c, et); results.add(entity); } // return... return results; } finally { if(c != null) c.close(); if(db != null) db.close(); } } That’s it! Now we can make our SQL queries more sophisticated. The reason I wanted to walk through adding the constraints to SqlFilter first was that we need to modify the code that gets the bookmarks from the local database to display in the navigator view.We’re about to start building our “Configuration” window. One of the things this will allow the user to do is delete bookmarks. However, we cannot delete bookmarks from our local database because if we do not have an item locally, we don’t know that the server version is not in sync and needs to be deleted.Thus, when we delete locally, we’ll “soft delete” rather than “hard delete” the item. We’ll do this by setting the LocalDeleted field of the bookmark to 1.This, then, begs the question that for our user interface, we need to not show soft deleted bookmarks—hence the need for the changes to SqlFilter."
12,"Explain why we can be confident that by the time we get through this process, not only have our changes have been merged, but also our local database contains an up-to-date set of what is on the server","We’ll split this section into two halves. The first half will look at the algorithm to detect changes between the server and local versions. The second half will look at building and sending the HTTP requests to the server. The code for detecting local changes is relatively easy to understand—once we know that we have changes, we can run some code to synchronize the data. We first update the server set, and when the pre-existing GetChanges method is executed, this will delete all of the local bookmarks and replace them with server versions again. Hence,we can be confident that by the time we get through this process, not only have our changes have been merged, but also our local database contains an up-to-date set of what is on the server.","(Recall that when we built this method, we ignored deleted items. This is important now, as had we not done this we would delete, say, ordinal 4, click Add, be given ordinal 4 to add, and when we got here, we would resurrect that item, as technically it is still in the database until we synchronize and refresh the items.) GetBookmarkByOrdinal may return a null item—that’s our cue to create a new one. In either case, we’ll track the bookmark that we have locally and populate the user interface via the view interface. package com.amxMobile.SixBookmarks; import com.amxMobile.SixBookmarks.Database.*; import com.amxMobile.SixBookmarks.Runtime.*; public class ConfigureSingletonController extends Controller<IConfigureSingletonView> { private Bookmark _bookmark; public ConfigureSingletonController(IConfigureSingletonView view) 191 CHAPTER 7 ■ ANDROID: PUSHING CHANGES TO THE SERVER { super(view); } public void HandleLoad() throws Exception { // get the ordinal from the intent... int ordinal = getActivity().getIntent().getExtras(). // load the bookmark... Bookmark bookmark = Bookmark.GetByOrdinal(this, ordinal); // if we didn't load one, create one... if(bookmark == null) { // create a new one... bookmark = new Bookmark(); bookmark.setOrdinal(ordinal); } // set... IConfigureSingletonView view = getView(); view.setOrdinal(ordinal); view.setName(bookmark.getName()); view.setUrl(bookmark.getUrl()); // store... _bookmark = bookmark; } private Bookmark getBookmark() { return _bookmark; } public void HandleSave() throws Exception { MessageBox.Show(this, ""TBD.""); } } Now we can run the project and configure a bookmark. Figure 7-9 shows a screenshot with the fields populated: 192 CHAPTER 7 ■ ANDROID: PUSHING CHANGES TO THE SERVER Figure 7-9. The singleton view allowing the user to review and edit a single bookmark We’re almost finished—all we have to do is implement HandleSave properly. All this method has to do is get the values back off of the view, validate them, populate the values in the stored bookmark instance, and save the changes to the database. Here’s the code: // Modify HandleSave method in ConfigureSingletonController… public void HandleSave() throws Exception { // get data... String name = getView().getName(); String url = getView().getUrl(); // both? Bookmark bookmark = getBookmark(); if(name != null && name.length() > 0 && url != null && url.length() > 0) { // set... bookmark.setName(name); bookmark.setUrl(url); bookmark.setLocalModified(true); bookmark.setLocalDeleted(false); 193 CHAPTER 7 ■ ANDROID: PUSHING CHANGES TO THE SERVER // save... bookmark.SaveChanges(this); getActivity().finish(); } else MessageBox.Show(this, ""Both name and URL must be provided.""); } That’s all we have to do! We can now change the data in our local database. All that remains is to physically pass the changes back to the server, which we’ll do in the second half of this chapter. In this section of the chapter, and the last of our work on Android, we’re going to look at pushing the changes back up to the server by adding more functionality to our Sync class.We’ll split this section into two halves. The first half will look at the algorithm to detect changes between the server and local versions. The second half will look at building and sending the HTTP requests to the server. The code for detecting local changes is relatively easy to understand—once we know that we have changes, we can run some code to synchronize the data. We first update the server set, and when the pre-existing GetChanges method is executed, this will delete all of the local bookmarks and replace them with server versions again. Thus, we can be confident that by the time we get through this process, not only have our changes have been merged, but also our local database contains an up-to-date set of what is on the server. Building the “PushUpdates” Method We’ll start by building the PushUpdates method. There’s going to be quite a lot of work here. In this section, we’ll first look at the algorithm for detecting changes, and then we’ll look at how we physically send changes up. • Download the latest set of bookmarks from the server. Walk each change detected on the client and find the matching server item based on the ordinal of the item. If a local change was found and that change can be mapped to a server item, issue an update to the server. If a local change was found and that change cannot be mapped to a server item, issue an insert to the server. If we delete a bookmark locally and a bookmark with that ordinal is in the server’s set, issue a delete to the server. CHAPTER 7 ■ ANDROID: PUSHING CHANGES TO THE SERVER To support this operation, we’ll need a method that updates a server bookmark, a second that inserts a server bookmark, and a third that deletes a server bookmark. If none of those applies, nothing will happen. We’ll add these stub methods to the ODataServiceProxy class now—recall that we built this class in the last chapter.■NOTE Although this implementation is going to be used only with bookmarks in this book, this approach will work with any sort of OData entity."
