,Question,Answer,Context
0,Explain why the search term in our example is App,"2. Open the res/values/strings.xml file in a text editor such as Eclipse (actually, any text editor that can do regular expression searches should work fine). Carry out a regular expression search (Ctrl-F Ctrl-X in Eclipse) for each of the menu words from step 1. Use the regular expression “.*” to separate the words. Hence,the search term in our example is App.","There are several subdirectories under samples/ApiDemos/src/com/example/android/ apis, each corresponding to a high-level functional area of the Android API: App Examples of application-level constructs such as Activities, Alarms, Dialogs, and Services. Content Describes how to read assets from a file, from resources, and from an XML file. Many types of graphics examples, such as arcs bitmap manipulation, clipping, layers, and OpenGL. Examples of the MediaPlayer and the VideoView. Examples of how to invoke operating system services. As of this writing, it shows how to use the VIBRATOR_SERVICE and SENSOR_SERVICE. Cool text tricks. The “Linkify” demo shows how to use the autoLink attribute of the TextView to automatically set up links in text: the user clicks on a URL and the browser comes up, or clicks on a phone number and the dialer appears. The “Log- TextBox” demo shows how to create a simple screen log with a LogTextBox View. All of the various Android views: buttons, text boxes, autocompletion, date widg- ets, etc. You can find the dozens of different Android GUI elements here, along with their many options. The ApiDemos application has a lot of interesting examples that will help you learn how to program an Android application. However, it’s not entirely obvious how to find the source to any particular screen. The following procedure will help you find the source to any ApiDemo you’re interested in. To understand the process, we’ll trace a couple of demos: the “App/Activity/Custom Title” and the “Text/Linkify” examples. This technique works when the ApiDemos application stores information about the demo in the res/strings.xml resource file: 1. After starting the ApiDemos application, find the particular demo by clicking on the menu, and remember the path you took through the menu system. In this case, you click on App, then Activity, and finally Custom Title.2. Open the res/values/strings.xml file in a text editor such as Eclipse (actually, any text editor that can do regular expression searches should work fine). Carry out a regular expression search (Ctrl-F Ctrl-X in Eclipse) for each of the menu words from step 1. Use the regular expression “.*” to separate the words. Thus, the search term in our example is App.*Activity.*Custom.*Title. The search should return zero or one result. If you don’t find any results, use the procedure in the following section of this chapter. Otherwise, the single result should be the contents of a string element.The value of the name attribute of that string element is our search term for the next step. For our example, this is activity_custom_title."
1,Explain why the CONTENT_URI defines the type of URIs your content provider can process,"Define CONTENT_URI. When a client application uses a content resolver to request data, a URI that identifies the desired data is passed to the content resolver. Android tries to match the URI with the CONTENT_URI of each content provider it knows about to find the right provider for the client. Hence,the CONTENT_URI defines the type of URIs your content provider can process.","NotePadProvider class and instance variables. As usual, it’s best to understand the major class and instance variables used by a method before examining how the method works. The variables we need to understand for the NotePad’s ContentProvider class are: private static final String DATABASE_NAME = ""note_pad.db""; private static final int DATABASE_VERSION = 2; private static final String NOTES_TABLE_NAME = ""notes""; private DatabaseHelper mOpenHelper; DATABASE_NAME The name of the database file on the device. For the NotePad project, the full path to the file is /data/data/com.example.android.notepad/databases/note_pad.db. DATABASE_VERSION The version of the database this code works with. If this number is higher than the version of the database itself, the application calls the DatabaseHelper.onUpdate method. See “Create the data storage” on page 122 for more information. The name of the notes table within the notes database. This instance variable is initialized during onCreate. It provides access to the da- tabase for the insert, query, update, and delete methods. has a static initialization block that performs complex initializations of static variables that can’t be performed as simple one-liners: private static HashMap<String, String> sNotesProjectionMap; private static final UriMatcher sUriMatcher; private static final int NOTES = 1; private static final int NOTE_ID = 2; ... static { sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH); sUriMatcher.addURI(NotePad.AUTHORITY, ""notes"", NOTES); sUriMatcher.addURI(NotePad.AUTHORITY, ""notes/#"", NOTE_ID); sNotesProjectionMap = new HashMap<String, String>(); sNotesProjectionMap.put(Notes._ID, Notes._ID); sNotesProjectionMap.put(Notes.TITLE, Notes.TITLE); sNotesProjectionMap.put(Notes.NOTE, Notes.NOTE); sNotesProjectionMap.put(Notes.CREATED_DATE, Notes.CREATED_DATE); sNotesProjectionMap.put(Notes.MODIFIED_DATE, Notes.MODIFIED_DATE); } The meanings of these variables follow: sNotesProjectionMap The projection map used by the query method. This HashMap maps the content provider’s column names to database column names. A projection map is not re- quired, but when used it must list all column names that might be returned by the query. In NotePadContentProvider, the content provider column names and the database column names are identical, so the sNotesProjectionMap is not required. This data structure is loaded with several URI templates that match URIs clients can send the content provider. Each URI template is paired with an integer that the sUriMatcher returns when it’s passed a matching URI. The integers are used as cases of a switch in other parts of the class. NotePadContentProvider has two types of URIs, represented by the NOTES and NOTES_ID integers. sUriMatcher returns this value for note URIs that do not include a note ID. NOTES_ID sUriMatcher returns this value when the notes URI includes a note ID.Define CONTENT_URI. When a client application uses a content resolver to request data, a URI that identifies the desired data is passed to the content resolver. Android tries to match the URI with the CONTENT_URI of each content provider it knows about to find the right provider for the client. Thus, the CONTENT_URI defines the type of URIs your content provider can process. content:// This initial string tells the Android framework that it must find a content provider to resolve the URI. This string uniquely identifies the content provider and consists of up to two sec- tions: the organizational section and the provider identifier section. The organiza- tional section uniquely identifies the organization that created the content pro- vider. The provider identifier section identifies a particular content provider that the organization created. For content providers that are built into Android, the organizational section is omitted. For instance, the built-in “media” authority that returns one or more images does not have the organizational section of the au- thority. However any content providers that are created by developers outside of Google’s Android team must define both sections of the content provider. Thus, the Notepad example application’s authority is com.google.provider.NotePad. The organizational section is com.google.provider, and the provider identifier section is NotePad. The Google documentation suggests that the best solution for picking the authority section of your CONTENT_URI is to use the fully qualified class name of the class implementing the content provider. droid will call to respond to queries that it handles. The content provider can interpret the rest of the URI however it wants, but it must adhere to some requirements: • If the content provider can return multiple data types, the URI must be con- structed so that some part of the path specifies the type of data to return. types of data: People, Phones, ContactMethods, etc. The Contacts content pro- vider uses strings in the URI to differentiate which type of data the user is re- questing. Thus, to request a specific person, the URI will be something like this: content://contacts/people/1 To request a specific phone number, the URI could be something like this: content://contacts/people/1/phone/3 Content Providers | 121 In the first case, the MIME data type returned will be vnd.android.cursor.item/ person, whereas in the second case, it will be vnd.android.cursor.item/phone.• The content provider must be capable of returning either one item or a set of item identifiers. The content provider will return a single item when an item identifier appears in the final portion of the URI. Looking back at our previous example, the URI content://contacts/people/1/phone/3 returned a single phone number of type vnd.android.cursor.item/phone. If the URI had instead been content://contacts/people/1/phone, the application would have returned a list of all of the phone numbers for the person having the person identifier number 1, and the MIME type of the data returned would be vnd.android.cursor.dir/ phone. URI however it wants. This means that it can use items in the path to filter data to return to the caller. For instance, the built-in “media” content provider can return either internal or external data, depending on whether the URI contains the word “internal” or “external” in the path."
