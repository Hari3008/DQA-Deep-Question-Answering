,Question,Answer,Context
0,Explain why it is no longer necessary to initialize ch—ch is assigned System,"Listing 2–18. Prompting the user to enter a specific character via a do-while statement int ch; do { System.out.println(""Press C or c to continue.""); ch = System.in.read(); } while (ch != 'C' && ch != 'c'); Listing 2–18 is similar to Listing 2–17. This time, however, the compound statement is executed prior to the test. Hence,it is no longer necessary to initialize ch—ch is assigned System.","Listing 2–18 demonstrates do-while in another example of prompting the user to enter a specific uppercase letter or its lowercase equivalent.Listing 2–18. Prompting the user to enter a specific character via a do-while statement int ch; do { System.out.println(""Press C or c to continue.""); ch = System.in.read(); } while (ch != 'C' && ch != 'c'); Listing 2–18 is similar to Listing 2–17. This time, however, the compound statement is executed prior to the test. As a result, it is no longer necessary to initialize ch—ch is assigned System.in.read()’s return value prior to the Boolean expression’s evaluation. for (String line; (line = readLine()) != null; System.out.println(line)); Listing 2–19 uses for to present a programming idiom for copying lines of text that are read from some source, via the fictitious readLine() method in this example, to some destination, via System.out.println() in this example. Copying continues until readLine() returns null. Note the semicolon (empty statement) at the end of the line.CAUTION: Be careful with the empty statement because it can introduce subtle bugs into your code. For example, the following code fragment is supposed to output Hello on ten lines."
1,Explain why Appt instances passed to the new addAppt() method are not logged,"Because a base class change can break a subclass, this problem is known as the fragile base class problem. A related cause of fragility that also has to do with overriding methods occurs when new methods are added to a superclass in a subsequent release. addAppt(Appt appt, boolean unique) method into the ApptCalendar class. This method adds the appt instance to the calendar when unique is false, and, when unique is true, adds the appt instance only if it has not previously been added. LoggingApptCalendar does not override the new addAppt() method with a call to Logger.log(). Hence,Appt instances passed to the new addAppt() method are not logged.","It is not a good idea to rely on an implementation detail when the detail is not documented. (I previously stated that you do not have access to ApptCalendar’s source code.) When a detail is not documented, it can change in a new version of the class.Because a base class change can break a subclass, this problem is known as the fragile base class problem. A related cause of fragility that also has to do with overriding methods occurs when new methods are added to a superclass in a subsequent release. addAppt(Appt appt, boolean unique) method into the ApptCalendar class. This method adds the appt instance to the calendar when unique is false, and, when unique is true, adds the appt instance only if it has not previously been added. LoggingApptCalendar does not override the new addAppt() method with a call to Logger.log(). As a result, Appt instances passed to the new addAppt() method are not logged.Here is another problem: You introduce a method into the subclass that is not also in the superclass. A new version of the superclass presents a new method that matches the subclass method signature and return type. Your subclass method now overrides the superclass method, and probably does not fulfill the superclass method’s contract."
2,Explain why the code that performs the illegal cast will not execute,"The virtual machine’s cast verification illustrates runtime type identification (or RTTI, for short). Cast verification performs RTTI by examining the type of the cast operator’s operand to see if the cast should be allowed. Clearly, the cast should not be allowed. operand to see if it is an instance of the right operand, and returns true if this is the case. if(a instanceof B) { B b = (B) a; b.d(); } The instanceof operator detects that variable a’s instance was not created from B and returns false to indicate this fact. Hence,the code that performs the illegal cast will not execute.","A third class named C provides a main() method that first instantiates A, and then tries to downcast this instance to B and assign the result to variable b. The compiler will not complain because downcasting from a superclass to a subclass in the same type hierarchy is legal. tries to execute b.d();. The crash happens because the virtual machine will attempt to call a method that does not exist—class A does not have a d() method. cast is legal. Because it detects that A does not have a d() method, it does not permit the cast by throwing an instance of the ClassCastException class.The virtual machine’s cast verification illustrates runtime type identification (or RTTI, for short). Cast verification performs RTTI by examining the type of the cast operator’s operand to see if the cast should be allowed. Clearly, the cast should not be allowed. operand to see if it is an instance of the right operand, and returns true if this is the case. if(a instanceof B) { B b = (B) a; b.d(); } The instanceof operator detects that variable a’s instance was not created from B and returns false to indicate this fact. As a result, the code that performs the illegal cast will not execute. (Overuse of instanceof probably indicates poor software design.) CHAPTER 3: Learning Object-Oriented Language Features 123 Because a subtype is a kind of supertype, instanceof will return true when its left operand is a subtype instance or a supertype instance of its right operand supertype. A a = new A(); B b = new B(); System.out.println(b instanceof A); // Output: true System.out.println(a instanceof A); // Output: true Listing 3–28, which assumes the class structure shown in Listing 3–26, instantiates superclass A and subclass B. The first System.out.println() method call outputs true because b’s reference identifies an instance of a subclass of A; the second System.out.println() method call outputs true because a’s reference identifies an instance of superclass A. So far, you have encountered two forms of RTTI. Java also supports a third form that is known as reflection. I will introduce you to this form of RTTI when I cover reflection in Chapter 7. A covariant return type is a method return type that, in the superclass’s method declaration, is the supertype of the return type in the subclass’s overriding method declaration. Listing 3–29 provides a demonstration of this language feature. class Zip { ZipFile getArchive(String name) throws IOException { return new ZipFile(name); // ZipFile is located in the java.util.zip package } } class Jar extends Zip { @Override JarFile getArchive(String name) throws IOException { return new JarFile(name); // JarFile is located in the java.util.jar package } } class Archive { public static void main(String[] args) throws IOException { if (args.length == 2 && args[0].equals(""-zip"")) { ZipFile zf = new Zip().getArchive(args[1]); } else if (args.length == 2 && args[0].equals(""-jar"")) { JarFile jf = new Jar().getArchive(args[1]); 124 CHAPTER 3: Learning Object-Oriented Language Features } } } Listing 3–29 declares a Zip superclass and a Jar subclass; each class declares a getArchive() method. Zip’s method has its return type set to ZipFile, whereas Jar’s overriding method has its return type set to JarFile, a subclass of ZipFile. getArchive() method does not need to upcast its JarFile instance to its JarFile return type. Furthermore, this instance does not need to be downcast to JarFile when assigning to variable jf.In the absence of covariant return types, you would end up with Listing 3–30. class Zip { ZipFile getArchive(String name) throws IOException { return new ZipFile(name); } } class Jar extends Zip { @Override ZipFile getArchive(String name) throws IOException { return new JarFile(name); } } class Archive2 { public static void main(String[] args) throws IOException { if (args.length == 2 && args[0].equals(""-zip"")) { ZipFile zf = new Zip().getArchive(args[1]); } else if (args.length == 2 && args[0].equals(""-jar"")) { JarFile jf = (JarFile) new Jar().getArchive(args[1]); } } } In Listing 3–30, the first bolded code reveals an upcast from JarFile to ZipFile, and the second bolded code uses the required (JarFile) cast operator to downcast from ZipFile to jf, which is of type JarFile. 125 Interfaces In Chapter 2, I stated that every class X exposes an interface, which is a protocol or contract consisting of constructors, methods, and (possibly) fields that are made available to objects created from other classes for use in creating and communicating with X’s objects."
3,Explain why i1 < i2 is converted to i1,"NOTE: Each of Byte, Long, and Short also maintains an internal cache of unique Byte, Long, and Short objects, respectively. reference, which is why i1 == i2 (which compares references) evaluates to true. returns a reference to a new Integer object, which is why i1 == i2 evaluates to false.In contrast to == and !=, which do not unbox the boxed values prior to the comparison, operators such as <, >, and + unbox these values before performing their operations. Hence,i1 < i2 is converted to i1.","NOTE: valueOf() is also used when adding a primitive value to a collection. For example, col.add(27) is converted to col.add(Integer.valueOf(27)). values. The low bound of this range is -128, and the high bound defaults to 127. property java.lang.Integer.IntegerCache.high (via the System class’s String setProperty(String prop, String value) method—I demonstrated this method’s getProperty() counterpart in Chapter 7).NOTE: Each of Byte, Long, and Short also maintains an internal cache of unique Byte, Long, and Short objects, respectively. reference, which is why i1 == i2 (which compares references) evaluates to true. returns a reference to a new Integer object, which is why i1 == i2 evaluates to false.In contrast to == and !=, which do not unbox the boxed values prior to the comparison, operators such as <, >, and + unbox these values before performing their operations. As a result, i1 < i2 is converted to i1.intValue() < i2.intValue() and i1 + i2 is converted to i1.intValue() + i2.intValue().CAUTION: Do not assume that autoboxing and unboxing are used in the context of the == and != operators. 325 List A list is an ordered collection, which is also known as a sequence. Elements can be stored in and accessed from specific locations via integer indexes. Some of these elements may be duplicates or null (when the list’s implementation allows null elements)."
4,Explain why access to the list’s elements is fast,"CAUTION: A view’s meaning becomes undefined when changes are made to the backing list.Therefore, you should only use subList() temporarily, whenever you need to perform a sequence of range operations on the backing list. 329 ArrayList The ArrayList class provides a list implementation that is based on an internal array. Hence,access to the list’s elements is fast.","The subList() method is useful for performing range-view operations over a list in a compact manner. For example, list.subList(fromIndex, toIndex).clear(); removes a range of elements from list where the first element is located at fromIndex and the last element is located at toIndex-1.CAUTION: A view’s meaning becomes undefined when changes are made to the backing list.Therefore, you should only use subList() temporarily, whenever you need to perform a sequence of range operations on the backing list. 329 ArrayList The ArrayList class provides a list implementation that is based on an internal array. As a result, access to the list’s elements is fast. However, because elements must be moved to open a space for insertion or to close a space after deletion, insertions and deletions of elements is slow. ArrayList() creates an empty array list with an initial capacity (storage space) of ten elements. Once this capacity is reached, a larger array is allocated, elements from the current array are copied into the larger array, and the larger array becomes the new current array. This process repeats as additional elements are added to the array list. containing collection’s elements in the order in which they are returned by the collection’s iterator. capacity of capacity elements. import java.util.ArrayList; import java.util.List; public class ArrayListDemo { public static void main(String[] args) { List<String> ls = new ArrayList<String>(); String[] weekDays = {""Sun"", ""Mon"", ""Tue"", ""Wed"", ""Thu"", ""Fri"", ""Sat""}; for (String weekDay: weekDays) ls. add(weekDay); dump(""ls:"", ls); ls.set(ls. indexOf(""Wed""), ""Wednesday""); dump(""ls:"", ls); ls.remove(ls. lastIndexOf(""Fri"")); dump(""ls:"", ls); } static void dump(String title, List<String> ls) { System.out.print(title + "" ""); for (String s: ls) System.out.print(s + "" ""); System.out.println(); } } 330 CHAPTER 8: Discovering the Collections Framework The dump() method’s enhanced for loop statement uses iterator(), hasNext(), and next() behind the scenes. ls: Sun Mon Tue Wed Thu Fri Sat ls: Sun Mon Tue Wednesday Thu Fri Sat ls: Sun Mon Tue Wednesday Thu Sat LinkedList The LinkedList class provides a list implementation that is based on linked nodes.Because links must be traversed, access to the list’s elements is slow. However, because only node references need to be changed, insertions and deletions of elements are fast. A node is a fixed sequence of value and link memory locations. Unlike an array, where each slot stores a single value of the same primitive type or reference supertype, a node can store multiple values of different types. It can also store links (references to other nodes). class Node { // value field String name; // link field Node next; } Node describes simple nodes where each node consists of a single name value field and a single next link field. Notice that next is of the same type as the class in which it is declared. This arrangement lets a node instance store a reference to another node instance (which is the next node) in this field. The resulting nodes are linked together."
5,Explain why LinkedHashSet’s iterator returns elements in the order in which they were inserted,"The easiest way to override hashCode() in Listing 8–9’s Planet class is to have the overriding method call the name field’s hashCode() method and return its value. (This technique only works with a class whose single reference field’s class provides a valid hashCode() method.) Listing 8–10 presents this overriding hashCode() method. @Override public int hashCode() { return name.hashCode(); } Introduce this method into the previous Planet class and run the application. You will observe output (similar to that shown below) that reveals no duplicate elements: true [Saturn, Earth, Uranus, Fomalhaut b, 51 Pegasi b, Venus, Jupiter, Mercury, Mars, Neptune] CHAPTER 8: Discovering the Collections Framework 337 NOTE: LinkedHashSet is a subclass of HashSet that uses a linked list to store its elements. Hence,LinkedHashSet’s iterator returns elements in the order in which they were inserted.","NOTE: equals() relies on a little known fact about the Java language: one instance’s private members can be accessed from another instance of the same class. For example, equals() can specify p.name to access p’s private name field. Directly accessing an instance’s private members in this manner is legal because encapsulation is not violated. true [Jupiter, Fomalhaut b, Neptune, Uranus, Venus, Earth, Mercury, 51 Pegasi b, Mars, Saturn, 51 Pegasi b] This output reveals two 51 Pegasi b elements in the hashset. Although these elements are equal from the perspective of the overriding equals() method (the first output line, true, proves this point), overriding equals() is not enough to avoid duplicate elements being stored in a hashset: you must also override hashCode().The easiest way to override hashCode() in Listing 8–9’s Planet class is to have the overriding method call the name field’s hashCode() method and return its value. (This technique only works with a class whose single reference field’s class provides a valid hashCode() method.) Listing 8–10 presents this overriding hashCode() method. @Override public int hashCode() { return name.hashCode(); } Introduce this method into the previous Planet class and run the application. You will observe output (similar to that shown below) that reveals no duplicate elements: true [Saturn, Earth, Uranus, Fomalhaut b, 51 Pegasi b, Venus, Jupiter, Mercury, Mars, Neptune] CHAPTER 8: Discovering the Collections Framework 337 NOTE: LinkedHashSet is a subclass of HashSet that uses a linked list to store its elements.As a result, LinkedHashSet’s iterator returns elements in the order in which they were inserted. For example, if Listing 8–8 had specified Set<String> ss = new LinkedHashSet<String>();, the application’s output would have been ss: apples pears grapes bananas kiwis null. Also, LinkedHashSet offers slower performance than HashSet and faster performance than TreeSet. Chapter 5 introduced you to traditional enumerated types and their enum replacement.(An enum is an enumerated type that is expressed via reserved word enum.) Listing 8–11 presents an example of a traditional enumerated type. public static final int SUNDAY = 1; public static final int MONDAY = 2; public static final int TUESDAY = 4; public static final int WEDNESDAY = 8; public static final int THURSDAY = 16; public static final int FRIDAY = 32; public static final int SATURDAY = 64; Although the enum has many advantages over the traditional enumerated type, the traditional enumerated type is less awkward to use when combining constants into a set; for example, public static final int DAYS_OFF = SUNDAY | MONDAY;."
6,Explain why a set-based range view can be used for a lengthy period of time,"The set-based range views returned from headSet(), subSet(), and tailSet() are analogous to the list-based range view returned from List’s subList() method except that a set-based range view remains valid even when the backing sorted set is modified. Hence,a set-based range view can be used for a lengthy period of time.","SortedSet, whose generic type is SortedSet<E>, extends Set. With two exceptions, the methods it inherits from Set behave identically on sorted sets as on other sets: The Iterator instance returned from iterator() traverses the sorted set in order. order. CHAPTER 8: Discovering the Collections Framework NOTE: Although not guaranteed, the toString() methods of SortedSet implementations in the collections framework (such as TreeSet) return a string containing all of the sorted set’s elements in order. standard constructors that I presented in my discussion of TreeSet. Furthermore, implementations of this interface must implement the methods that are described in Table 8–3. Method Description Comparator<? Return the comparator used to order the elements in this set, or null when this super E> set uses the natural ordering of its elements. E first() Return the first (lowest) element currently in this set, or throw a NoSuchElementException instance when this set is empty. Return a view of that portion of this set whose elements are strictly less than headSet(E toElement. The returned set is backed by this set, so changes in the returned toElement) set are reflected in this set and vice versa. The returned set supports all optional set operations that this set supports. This method throws ClassCastException when toElement is not compatible with this set’s comparator (or, when the set has no comparator, when toElement does not implement Comparable), NullPointerException when toElement is null and this set does not permit null elements, and IllegalArgumentException when this set has a restricted range and toElement lies outside of this range’s bounds. Return the last (highest) element currently in this set, or throw a NoSuchElementException instance when this set is empty. Return a view of the portion of this set whose elements range from subSet(E fromElement, inclusive, to toElement, exclusive. (When fromElement and fromElement, E toElement are equal, the returned set is empty.) The returned set is backed by toElement) this set, so changes in the returned set are reflected in this set and vice versa. cannot be compared to one another using this set’s comparator (or, when the set has no comparator, using natural ordering), NullPointerException when fromElement or toElement is null and this set does not permit null elements, and IllegalArgumentException when fromElement is greater than toElement or when this set has a restricted range and fromElement or toElement lies outside of this range’s bounds. 341 Method Description SortedSet<E> Return a view of that portion of this set whose elements are greater than or tailSet(E equal to fromElement. The returned set is backed by this set, so changes in the fromElement) returned set are reflected in this set and vice versa. The returned set supports all optional set operations that this set supports. This method throws ClassCastException when fromElement is not compatible with this set’s comparator (or, when the set has no comparator, when fromElement does not implement Comparable), NullPointerException when fromElement is null and this set does not permit null elements, and IllegalArgumentException when this set has a restricted range and fromElement lies outside of the range’s bounds.The set-based range views returned from headSet(), subSet(), and tailSet() are analogous to the list-based range view returned from List’s subList() method except that a set-based range view remains valid even when the backing sorted set is modified.As a result, a set-based range view can be used for a lengthy period of time.NOTE: Unlike a list-based range view whose endpoints are elements in the backing list, the endpoints of a set-based range view are absolute points in element space, allowing a set-based range view to serve as a window onto a portion of the set’s element space. Any changes made to the set-based range view are written back to the backing sorted set and vice versa."
7,Explain why LinkedHashMap’s iterator returns entries in the order in which they were inserted,"When you run this application, its last two lines of output are of the most interest. application now correctly presents first point followed by first point on these lines.NOTE: LinkedHashMap is a subclass of HashMap that uses a linked list to store its entries. Hence,LinkedHashMap’s iterator returns entries in the order in which they were inserted.","TIP: Instead of using this or another algorithm to create a hash code, you might find it easier to work with the HashCodeBuilder class (see http://commons.apache.org/lang/api- 2.4/org/apache/commons/lang/builder/HashCodeBuilder.html for an explanation of this class). This class, which follows Bloch’s rules, is part of the Apache Commons Lang component, which you can download from http://commons.apache.org/lang/. In Chapter 3, Listing 3-9’s Point class overrides equals() but does not override hashCode(). Listing 3-11 presents a small code fragment that must be appended to Point’s main() method to demonstrate the problem of not overriding hashCode(). I restate this problem here: Although objects p1 and Point(10, 20) are logically equivalent, these objects have different hash codes, resulting in each object referring to a different entry in the hashmap. If an object is not stored (via put()) in that entry, get() returns null. 361 Listing 8–25 modifies Listing 3-9’s Point class by declaring a hashCode() method. This method uses the aforementioned algorithm to ensure that logically equivalent Point objects hash to the same entry. import java.util.HashMap; import java.util.Map; class Point { private int x, y; Point(int x, int y) { this.x = x; this.y = y; } int getX() { return x; } int getY() { return y; } @Override public boolean equals(Object o) { if (!(o instanceof Point)) return false; Point p = (Point) o; return p.x == x && p.y == y; } @Override public int hashCode() { int hashCode = 19; int hc = x; hashCode = hashCode*31+hc; hc = y; hashCode = hashCode*31+hc; return hc; } public static void main(String[] args) { Point p1 = new Point(10, 20); Point p2 = new Point(20, 30); Point p3 = new Point(10, 20); // Test reflexivity System.out.println(p1.equals(p1)); // Output: true // Test symmetry System.out.println(p1.equals(p2)); // Output: false System.out.println(p2.equals(p1)); // Output: false // Test transitivity System.out.println(p2.equals(p3)); // Output: false System.out.println(p1.equals(p3)); // Output: true // Test nullability 362 CHAPTER 8: Discovering the Collections Framework System.out.println(p1.equals(null)); // Output: false // Extra test to further prove the instanceof operator's usefulness. Map<Point, String> map = new HashMap<Point, String>(); map.put(p1, ""first point""); System.out.println(map.get(p1)); // Output: first point System.out.println(map.get(new Point(10, 20))); // Output: null } } The hashCode() method is a little verbose in that it assigns each of x and y to local variable hc, rather than directly using these fields in the hash code calculation. However, I decided to follow this approach to more closely mirror the hash code algorithm.When you run this application, its last two lines of output are of the most interest. application now correctly presents first point followed by first point on these lines.NOTE: LinkedHashMap is a subclass of HashMap that uses a linked list to store its entries. As a result, LinkedHashMap’s iterator returns entries in the order in which they were inserted. For example, if Listing 8–24 had specified Map<String, Integer> argMap = new LinkedHashMap<String, Integer>();, the application’s output for java HashMapDemo how much wood could a woodchuck chuck if a woodchuck could chuck wood would have been {how=1, much=1, wood=2, could=2, a=2, woodchuck=2, chuck=2, if=1} followed by Number of distinct arguments = 8. The IdentityHashMap class provides a Map implementation that uses reference equality (==) instead of object equality (equals()) when comparing keys and values. This is an intentional violation of Map’s general contract, which mandates the use of equals() when comparing elements. x) method instead of via each key’s hashCode() method. identityHashCode() returns the same hash code for x as returned by Object’s hashCode() method, whether or not x’s class overrides hashCode(). The hash code for the null reference is zero. implementations. Also, IdentityHashMap supports mutable keys (objects used as keys and whose hash codes change when their field values change while in the map). Listing 8–26 contrasts IdentityHashMap with HashMap where mutable keys are concerned. import java.util.IdentityHashMap; import java.util.HashMap; import java.util.Map; CHAPTER 8: Discovering the Collections Framework 363 public class IdentityHashMapDemo { public static void main(String[] args) { Map<Employee, String> map1 = new IdentityHashMap<Employee, String>(); Map<Employee, String> map2 = new HashMap<Employee, String>(); Employee e1 = new Employee(""John Doe"", 28); map1. put(e1, ""SALES""); System.out.println(map1); Employee e2 = new Employee(""Jane Doe"", 26); map2. put(e2, ""MGMT""); System.out.println(map2); System.out.println(""map1 contains key e1 = "" + map1. containsKey(e1)); System.out.println(""map2 contains key e2 = "" + map2. containsKey(e2)); e1. setAge(29); e2. setAge(27); System.out.println(map1); System.out.println(map2); System.out.println(""map1 contains key e1 = "" + map1. containsKey(e1)); System.out.println(""map2 contains key e2 = "" + map2. containsKey(e2)); } } class Employee { private String name; private int age; Employee(String name, int age) { this.name = name; this.age = age; } @Override public boolean equals(Object o) { if (!(o instanceof Employee)) return false; Employee e = (Employee) o; return e.name.equals(name) && e.age == age; } @Override public int hashCode() { int hashCode = 19; hashCode = hashCode*31+name.hashCode(); hashCode = hashCode*31+age; return hashCode; } void setAge(int age) { this.age = age; } void setName(String name) { this.name = name; } @Override public String toString() 364 CHAPTER 8: Discovering the Collections Framework { return name + "" "" + age; } } Listing 8–26’s main() method creates IdentityHashMap and HashMap instances that each store an entry consisting of an Employee key and a String value. Because Employee instances are mutable (because of setAge() and setName()), main() changes their ages while these keys are stored in their maps. These changes result in the following output: {John Doe 28=SALES} {Jane Doe 26=MGMT} map1 contains key e1 = true map2 contains key e2 = true {John Doe 29=SALES} {Jane Doe 27=MGMT} map1 contains key e1 = true map2 contains key e2 = false The last four lines show that the changed entries remain in their maps. However, map2’s containsKey() method reports that its HashMap instance no longer contains its Employee key (which should be Jane Doe 27), whereas map1’s containsKey() method reports that its IdentityHashMap instance still contains its Employee key, which is now John Doe 29.NOTE: IdentityHashMap’s documentation states that “a typical use of this class is topology-preserving object graph transformations, such as serialization or deep copying.” (I discuss serialization in Chapter 10.) It also states that “another typical use of this class is to maintain proxy objects.” Also, developers responding to stackoverflow’s “Use Cases for Identity HashMap” topic (http://stackoverflow.com/questions/838528/use-cases-for-identity- hashmap) mention that it is much faster to use IdentityHashMap than HashMap when the keys are Class objects. The WeakHashMap class provides a Map implementation that is based on weakly reachable keys. Because each key object is stored indirectly as the referent of a weak reference, the key is automatically removed from the map only after the garbage collector clears all weak references to the key (inside and outside of the map)."
8,"Explain why write operations are slower than if the random access file was opened in ""rw"" mode","Data that is written to an open file ends up being stored in the underlying platform’s output buffers. When the buffers fill to capacity, the platform empties them to the disk.However, when you write data to a random access file that has been opened via mode ""rwd"" or ""rws"", each write operation’s data is written straight to the disk. Hence,write operations are slower than if the random access file was opened in ""rw"" mode.","NOTE: A handle is an identifier that Java passes to the underlying platform to identify, in this case, a specific open file when it requires that the underlying platform perform a file operation. out, and err. These constants let System.in, System.out, and System.err provide access to the standard input, standard output, and standard error streams. void sync() tells the underlying platform to flush (empty) the contents of the open file’s output buffers to their associated local disk device. to the relevant device. It throws SyncFailedException when the buffers cannot be flushed, or because the platform cannot guarantee that all the buffers have been synchronized with physical media. is valid. It returns true when the file descriptor object represents an open file or other active I/O connection; otherwise, it returns false.Data that is written to an open file ends up being stored in the underlying platform’s output buffers. When the buffers fill to capacity, the platform empties them to the disk.However, when you write data to a random access file that has been opened via mode ""rwd"" or ""rws"", each write operation’s data is written straight to the disk. As a result, write operations are slower than if the random access file was opened in ""rw"" mode. writing data directly to the disk. Listing 10–6 addresses this hybrid scenario by opening the file in mode ""rw"" and selectively calling FileDescriptor’s sync() method. RandomAccessFile raf = new RandomAccessFile(""employee.dat"", ""rw""); FileDescriptor fd = raf.getFD(); // Perform a critical write operation. // Synchronize with underlying disk by flushing platform's output buffers to disk. 467 fd.sync(); // Perform non-critical write operation where synchronization is not necessary. // Do other work. RandomAccessFile is useful for creating a flat file database, a single file organized into records and fields. A record stores a single entry (such as a part in a parts database) and a field stores a single attribute of the entry (such as a part number). records. Each record is further organized into one or more fixed-length fields. Figure 10– 1 illustrates this concept in the context of a parts database. According to Figure 10–1, each field has a name (partnum, desc, qty, and ucost). Also, each record is assigned a number starting at 0. This example consists of five records, of which only three are shown for brevity.NOTE: The term field is also used to refer to a variable declared within a class. To avoid confusion with this overloaded terminology, think of a field variable as being analogous to a record’s field attribute."
9,"Explain why the same bytecode runs unchanged on Windows-based, Linux-based, Mac OS X–based, and other platforms","4. The answer is true: a classfile’s instructions are commonly referred to as bytecode. instructions is being executed repeatedly, it informs the virtual machine’s Just In Time (JIT) compiler to compile these instructions into native code. underlying platform. Hence,the same bytecode runs unchanged on Windows-based, Linux-based, Mac OS X–based, and other platforms.","2. A virtual machine is a software-based processor that presents its own instruction set. (and associated data) that are executed by the virtual machine.4. The answer is true: a classfile’s instructions are commonly referred to as bytecode. instructions is being executed repeatedly, it informs the virtual machine’s Just In Time (JIT) compiler to compile these instructions into native code. underlying platform. As a result, the same bytecode runs unchanged on Windows-based, Linux-based, Mac OS X–based, and other platforms. code executes. It accomplishes this task in part by using a bytecode verifier to make sure that the classfile’s bytecode is valid.8. The answer is false: Java SE is the platform for developing applications and applets. 534 APPENDIX: Solutions to Exercises 9. The JRE implements the Java SE platform and makes it possible to run Java programs."
10,Explain why this situation does not result in an illegal forward reference,"17. It is okay for an expression assigned to an instance field to access a class field that is declared after the instance field because all class fields are initialized before any instance fields are initialized. The compiler knows that the virtual machine will know about the class fields before an object is created. Hence,this situation does not result in an illegal forward reference.","16. Initializing the sines array using the new syntax yields double[] sines = new double[360];. Initializing the cosines array using the new syntax yields double[] cosines = new double[360];.17. It is okay for an expression assigned to an instance field to access a class field that is declared after the instance field because all class fields are initialized before any instance fields are initialized. The compiler knows that the virtual machine will know about the class fields before an object is created. As a result, this situation does not result in an illegal forward reference.18. Creating an array of objects requires that you first use new to create the array, and then assign an object reference to each of the array’s elements."
11,Explain why entries are stored in sorted order of their keys,"37. A map is a group of key/value pairs (also known as entries).38. The TreeMap class provides a map implementation that is based on a red-black tree. Hence,entries are stored in sorted order of their keys.","36. The PriorityQueue class provides an implementation of a priority queue, which is a queue that orders its elements according to their natural ordering or by a comparator provided when the queue is instantiated.37. A map is a group of key/value pairs (also known as entries).38. The TreeMap class provides a map implementation that is based on a red-black tree. As a result, entries are stored in sorted order of their keys. data structure. hash codes; they identify hashtable array elements, which are known as buckets or slots.43. A hashtable’s load factor refers to the ratio of the number of stored entries divided by the number of buckets. APPENDIX: Solutions to Exercises 44. The difference between HashMap and LinkedHashMap is that LinkedHashMap uses a linked list to store its entries, resulting in its iterator returning entries in the order in which they were inserted. equality (==) instead of object equality (equals()) when comparing keys and values. reachable keys. the same enum."
12,Explain why we must refine this pseudocode to facilitate the translation process,"10. If the deck has no more cards, empty the discard pile to the deck and shuffle the deck. achieving an application that implements Four of a Kind. This pseudocode performs various tasks, including decision making and repetition.Despite being a more useful guide to understanding how Four of a Kind works, Listing 1–3 is too high level for translation to Java. Hence,we must refine this pseudocode to facilitate the translation process.","8. The current player picks up the deck's top card. If the current player has four of a kind, it puts down its cards and wins the game.10. If the deck has no more cards, empty the discard pile to the deck and shuffle the deck. achieving an application that implements Four of a Kind. This pseudocode performs various tasks, including decision making and repetition.Despite being a more useful guide to understanding how Four of a Kind works, Listing 1–3 is too high level for translation to Java. Therefore, we must refine this pseudocode to facilitate the translation process. Listing 1–4 presents this refinement.Listing 1–4. Refined Four of a Kind pseudocode for two players (human and computer) 1. deck = new Deck() 2. deck.shuffle() 3. discardPile = new DiscardPile() 4. hCard = deck.deal() 5. cCard = deck.deal() 6. if hCard.rank() == cCard.rank() 6.1. deck.putBack(hCard) 6.2. deck.putBack(cCard) 6.3. deck.shuffle() 6.4. Repeat at step 4 7. curPlayer = HUMAN 7.1. if cCard.rank() > hCard.rank() 7.1.1. curPlayer = COMPUTER 8. deck.putBack(hCard) 9. deck.putBack(cCard) 10. if curPlayer == HUMAN 10.1. for i = 0 to 3 10.1.1. cCards[i] = deck.deal() 10.1.2. hCards[i] = deck.deal() else 10.2. for i = 0 to 3 10.2.1. hCards[i] = deck.deal() 10.2.2. cCards[i] = deck.deal() 11. if curPlayer == HUMAN 11.01. output(hCards) 11.02. choice = prompt(""Identify card to throw away"") 11.03. discardPile.setTopCard(hCards[choice]) 11.04. hCards[choice] = deck.deal() 11.05. if isFourOfAKind(hCards) 11.05.1. output(""Human wins!"") 11.05.2. putDown(hCards) 11.05.3. output(""Computer's cards:"") 11.05.4. putDown(cCards) 11.05.5. End game 11.06. curPlayer = COMPUTER CHAPTER 1: Getting Started with Java 23 else 11.07. choice = leastDesirableCard(cCards) 11.08. discardPile.setTopCard(cCards[choice]) 11.09. cCards[choice] = deck.deal() 11.10. if isFourOfAKind(cCards) 11.10.1. output(""Computer wins!"") 11.10.2. putDown(cCards) 11.10.3. End game 11.11. curPlayer = HUMAN 12. if deck.isEmpty() 12.1. if discardPile.topCard() != null 12.1.1. deck.putBack(discardPile.getTopCard()) 12.1.2. Repeat at step 12.1. 13. Repeat at step 11. becoming more like Java. For example, Listing 1–4 reveals Java expressions (such as new Deck(), to create a Deck object), operators (such as ==, to compare two values for equality), and method calls (such as deck.isEmpty(), to call deck’s isEmpty() method to return a Boolean value indicating whether [true] or not [false] the deck identified by deck is empty of cards). Now that you have had a chance to absorb Listing 1–4’s Java-like pseudocode, you are ready to examine the process of converting that pseudocode to Java source code. This process consists of a couple of steps. important components of the game’s structure and implementing these components as classes. I will formally introduce classes in Chapter 2."
13,Explain why it is redundant to declare them with these reserved words,"An interface’s fields are implicitly declared public, static, and final. It is therefore redundant to declare them with these reserved words. Because these fields are constants, they must be explicitly initialized; otherwise, the compiler reports an error.An interface’s methods are implicitly declared public and abstract. Hence,it is redundant to declare them with these reserved words.","Because an interface is already abstract, it is redundant to specify abstract in the interface’s declaration.An interface’s fields are implicitly declared public, static, and final. It is therefore redundant to declare them with these reserved words. Because these fields are constants, they must be explicitly initialized; otherwise, the compiler reports an error.An interface’s methods are implicitly declared public and abstract. Therefore, it is redundant to declare them with these reserved words. Because these methods must be instance methods, do not declare them static or the compiler will report errors.Drawable identifies a type that specifies what to do (draw something) but not how to do it. Implementation details are left up to classes that implement this interface. Instances of such classes are known as drawables because they know how to draw themselves."
14,"Explain why you should only use subList() temporarily, whenever you need to perform a sequence of range operations on the backing list","CAUTION: A view’s meaning becomes undefined when changes are made to the backing list. Hence,you should only use subList() temporarily, whenever you need to perform a sequence of range operations on the backing list.","The subList() method is useful for performing range-view operations over a list in a compact manner. For example, list.subList(fromIndex, toIndex).clear(); removes a range of elements from list where the first element is located at fromIndex and the last element is located at toIndex-1.CAUTION: A view’s meaning becomes undefined when changes are made to the backing list.Therefore, you should only use subList() temporarily, whenever you need to perform a sequence of range operations on the backing list. 329 ArrayList The ArrayList class provides a list implementation that is based on an internal array. As a result, access to the list’s elements is fast. However, because elements must be moved to open a space for insertion or to close a space after deletion, insertions and deletions of elements is slow. ArrayList() creates an empty array list with an initial capacity (storage space) of ten elements. Once this capacity is reached, a larger array is allocated, elements from the current array are copied into the larger array, and the larger array becomes the new current array. This process repeats as additional elements are added to the array list. containing collection’s elements in the order in which they are returned by the collection’s iterator. capacity of capacity elements. import java.util.ArrayList; import java.util.List; public class ArrayListDemo { public static void main(String[] args) { List<String> ls = new ArrayList<String>(); String[] weekDays = {""Sun"", ""Mon"", ""Tue"", ""Wed"", ""Thu"", ""Fri"", ""Sat""}; for (String weekDay: weekDays) ls. add(weekDay); dump(""ls:"", ls); ls.set(ls. indexOf(""Wed""), ""Wednesday""); dump(""ls:"", ls); ls.remove(ls. lastIndexOf(""Fri"")); dump(""ls:"", ls); } static void dump(String title, List<String> ls) { System.out.print(title + "" ""); for (String s: ls) System.out.print(s + "" ""); System.out.println(); } } 330 CHAPTER 8: Discovering the Collections Framework The dump() method’s enhanced for loop statement uses iterator(), hasNext(), and next() behind the scenes. ls: Sun Mon Tue Wed Thu Fri Sat ls: Sun Mon Tue Wednesday Thu Fri Sat ls: Sun Mon Tue Wednesday Thu Sat LinkedList The LinkedList class provides a list implementation that is based on linked nodes.Because links must be traversed, access to the list’s elements is slow. However, because only node references need to be changed, insertions and deletions of elements are fast. A node is a fixed sequence of value and link memory locations. Unlike an array, where each slot stores a single value of the same primitive type or reference supertype, a node can store multiple values of different types. It can also store links (references to other nodes). class Node { // value field String name; // link field Node next; } Node describes simple nodes where each node consists of a single name value field and a single next link field. Notice that next is of the same type as the class in which it is declared. This arrangement lets a node instance store a reference to another node instance (which is the next node) in this field. The resulting nodes are linked together."
