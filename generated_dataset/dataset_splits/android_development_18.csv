,Question,Answer,Context
0,Explain why developer interest in Android devices has made their 2008 release a hugely anticipated mobile technology event,"Android hardware will be designed to tempt consumers, but the real win is for developers. With existing mobile development built on proprietary operating systems that restrict third-party applications, Android offers an open and equal alternative. Without artifi cial barriers, Android developers are free to write applications that take full advantage of increasingly powerful mobile hardware. Hence,developer interest in Android devices has made their 2008 release a hugely anticipated mobile technology event.","Thanks also to Paul, Stu, and Mike: Your friendship and inspiration helped me get to where I am. 10/20/08 4:08:56 PM Contents Introduction xvii Chapter 1: Hello , Android 1 A Little Background 2 The Not So Distant Past 2 The Future 3 What It Isn’t 3 An Open Platform for Mobile Development 4 Native Android Applications 4 Android SDK Features 5 Access to Hardware including Camera, GPS, and Accelerometer 6 Native Google Maps, Geocoding, and Location-Based Services 6 Background Services 6 SQLite Database for Data Storage and Retrieval 7 Shared Data and Interapplication Communication 7 P2P Services with Google Talk 7 Extensive Media Support and 2D/3D Graphics 8 Optimized Memory and Process Management 8 Introducing the Open Handset Alliance 8 What Does Android Run On? 9 Why Develop for Android? 9 What Will Drive Android Adoption? 10 What Does It Have That Others Don’t? 10 Changing the Mobile Development Landscape 11 Introducing the Development Framework 11 What Comes in the Box 12 Understanding the Android Software Stack 12 The Dalvik Virtual Machine 14 Android Application Architecture 14 Android Libraries 15 Advanced Android Libraries 16 Summary 17 44712ftoc.indd ix 10/21/08 12:07:15 AM Contents Chapter 2: Get ting Started 19 Developing for Android 20 What You Need to Begin 20 Creating Your First Android Activity 24 Types of Android Applications 29 Developing for Mobile Devices 30 Hardware-Imposed Design Considerations 30 Considering the Users’ Environment 33 Developing for Android 34 To-Do List Example 37 Android Development Tools 42 The Android Emulator 42 Dalvik Debug Monitor Service (DDMS) 43 The Android Debug Bridge (ADB) 43 Summary 44 Chapter 3: Cr eating Applications and Activities 45 What Makes an Android Application? 46 Introducing the Application Manifest 46 Using the Manifest Editor 49 The Android Application Life Cycle 50 Understanding Application Priority and Process States 51 Externalizing Resources 52 Creating Resources 53 Using Resources 59 To-Do List Resources Example 62 Creating Resources for Different Languages and Hardware 63 Runtime Confi guration Changes 64 A Closer Look at Android Activities 66 Creating an Activity 66 The Activity Life Cycle 68 Android Activity Classes 73 Summary 73 Chapter 4: Cr eating User Interfaces 75 Fundamental Android UI Design 76 Introducing Views 76 Creating Activity User Interfaces with Views 77 The Android Widget Toolbox 78 x 44712ftoc.indd x 10/21/08 12:07:15 AM Contents Introducing Layouts 79 Using Layouts 79 Creating New Views 80 Modifying Existing Views 81 Creating Compound Controls 85 Creating Custom Widgets and Controls 88 Using Custom Controls 98 Creating and Using Menus 99 Introducing the Android Menu System 99 Defi ning an Activity Menu 101 Dynamically Updating Menu Items 104 Handling Menu Selections 104 Submenus and Context Menus 105 To-Do List Example Continued 107 Summary 112 Chapter 5: Int ents, Broadcast Receivers, Adapters, and the Internet 113 Introducing Intents 114 Using Intents to Launch Activities 114 Using Intent Filters to Service Implicit Intents 121 Using Intent Filters for Plug-ins and Extensibility 130 Using Intents to Broadcast Events 132 Introducing Adapters 136 Introducing Some Android-Supplied Adapters 136 Using Adapters for Data Binding 136 Using Internet Resources 141 Connecting to an Internet Resource 142 Leveraging Internet Resources 143 Introducing Dialogs 143 Introducing the Dialog Class 144 Using Activities as Dialogs 147 Creating an Earthquake Viewer 148 Summary 157 Chapter 6: D ata Storage, Retrieval, and Sharing 159 Android Techniques for Saving Data 160 Saving Simple Application Data 160 Creating and Saving Preferences 161 Retrieving Shared Preferences 161 Saving the Activity State 162 Creating a Preferences Page for the Earthquake Viewer 165 xi 44712ftoc.indd xi 10/21/08 12:07:15 AM Contents Saving and Loading Files 174 Including Static Files as Resources 174 File Management Tools 175 Databases in Android 175 Introducing SQLite 176 Cursors and Content Values 176 Working with Android Databases 177 Introducing Content Providers 189 Using Content Providers 189 Native Android Content Providers 192 Creating a New Content Provider 194 Creating and Using an Earthquake Content Provider 197 Summary 205 Chapter 7: Map s, Geocoding, and Location-Based Services 207 Using Location-Based Services 208 Setting up the Emulator with Test Providers 208 Updating Locations in Emulator Location Providers 208 Create an Application to Manage Test Location Providers 209 Selecting a Location Provider 212 Finding the Available Providers 212 Finding Providers Based on Requirement Criteria 212 Finding Your Location 213 “Where Am I?” Example 214 Tracking Movement 216 Updating Your Location in “Where Am I?” 217 Using Proximity Alerts 219 Using the Geocoder 220 Reverse Geocoding 221 Forward Geocoding 221 Geocoding “Where Am I?” 222 Creating Map-Based Activities 224 Introducing MapView and MapActivity 224 Creating a Map-Based Activity 224 Confi guring and Using Map Views 226 Using the Map Controller 227 Mapping “Where Am I?” 228 Creating and Using Overlays 231 Introducing MyLocationOverlay 239 Introducing ItemizedOverlays and OverlayItems 239 Pinning Views to the Map and Map Positions 240 xii 44712ftoc.indd xii 10/21/08 12:07:15 AM Contents Mapping Earthquakes Example 242 Summary 247 Chapter 8: W orking in the Background 249 Introducing Services 250 Creating and Controlling Services 250 Binding Activities to Services 258 Using Background Worker Threads 259 Creating New Threads 260 Synchronizing Threads for GUI Operations 260 Moving the Earthquake Service to a Background Thread 261 Let’s Make a Toast 262 Customizing Toasts 263 Using Toasts in Worker Threads 264 Introducing Notifi cations 265 Introducing the Notifi cation Manager 266 Creating Notifi cations 266 Triggering Notifi cations 267 Adding Notifi cations to the Earthquake Monitor 267 Advanced Notifi cation Techniques 270 Ongoing and Insistent Notifi cations 272 Using Alarms 273 Using Alarms to Update Earthquakes 274 Summary 276 Chapter 9: Pe er-to-Peer Communication 279 Introducing Android Instant Messaging 280 Using the GTalk Service 280 Binding to the GTalk Service 281 Making a GTalk Connection and Starting an IM Session 282 Introducing Presence and the Contact Roster 283 Managing Chat Sessions 286 Sending and Receiving Data Messages 289 Introducing SMS 291 Using SMS in Your Application 291 Sending SMS Messages 292 Listening for SMS Messages 294 Emergency Responder SMS Example 297 Automating the Emergency Responder 306 Summary 314 xiii 44712ftoc.indd xiii 10/21/08 12:07:15 AM Contents Chapter 10 A : ccessing Android Hardware 315 Using the Media APIs 316 Playing Media Resources 316 Recording Multimedia 317 Using the Camera 319 Controlling Camera Settings 319 Using the Camera Preview 320 Taking a Picture 320 Introducing the Sensor Manager 321 Using the Accelerometer and Compass 323 Introducing Accelerometers 324 Detecting Acceleration Changes 324 Creating a Speedometer 326 Determining Your Orientation 329 Creating a Compass and Artifi cial Horizon 330 Android Telephony 333 Making Phone Calls 334 Monitoring Phone State and Phone Activity 334 Monitoring Data Connectivity and Activity 337 Accessing Phone Properties and Status 338 Controlling the Phone 338 Using Bluetooth 339 Introducing the Bluetooth Service 339 Controlling the Local Bluetooth Device 340 Discovering and Bonding with Bluetooth Devices 340 Managing Bluetooth Connections 342 Communication with Bluetooth 342 Using a Bluetooth Headset 344 Managing Network and Wi-Fi Connections 345 Monitoring and Managing Your Internet Connectivity 345 Managing Active Connections 346 Managing Your Wi-Fi 347 Controlling Device Vibration 350 Summary 351 Chapter 11 A : dvanced Android Development 353 Paranoid Android 354 Linux Kernel Security 354 Introducing Permissions 354 Declaring and Enforcing Permissions 355 Enforcing Permissions with Broadcasting Intents 355 xiv 44712ftoc.indd xiv 10/21/08 12:07:15 AM Contents Using AIDL to Support IPC for Services 356 Implementing an AIDL Interface 356 Using Internet Services 361 Building Rich User Interfaces 361 Working with Animations 361 Using Themes to Skin Your Applications 372 Advanced Canvas Drawing 373 Introducing SurfaceView 390 Creating Interactive Controls 393 Summary 398 Index 399 xv 44712ftoc.indd xv 10/21/08 12:07:15 AM 44712flast.indd xvi 10/21/08 12:11:04 AM Introduction Now is an exciting time for mobile developers. Mobile phones have never been more popular, and powerful smartphones are now a regular choice for consumers. Stylish and versatile phones packing hardware features like GPS, accelerometers, and touch screens are an enticing platform upon which to create innovative mobile applications.Android hardware will be designed to tempt consumers, but the real win is for developers. With existing mobile development built on proprietary operating systems that restrict third-party applications, Android offers an open and equal alternative. Without artifi cial barriers, Android developers are free to write applications that take full advantage of increasingly powerful mobile hardware. As a result, developer interest in Android devices has made their 2008 release a hugely anticipated mobile technology event.Built on an open source framework, and featuring powerful SDK libraries and an open philosophy, Android has opened mobile phone development to thousands of developers who haven’t had access to tools for building mobile applications. Experienced mobile developers can now expand into the Android platform, leveraging the unique features to enhance existing products or create innovative new ones."
1,"Explain why you get the benefi ts of using Java, while your applications have the advantage of running on a virtual machine optimized for Android devices","Versions of the SDK, Java, and Eclipse are available for Windows, Mac OS, and Linux, so you can explore Android from the comfort of whatever OS you favor. The SDK includes an emulator for all three OS environments, and because Android applications are run on a virtual machine, there’s no advantage to developing from any particular operating system.Android code is written using Java syntax, and the core Android libraries include most of the features from the core Java APIs. Before they can be run, though, your projects are fi rst translated into Dalvik byte code. Hence,you get the benefi ts of using Java, while your applications have the advantage of running on a virtual machine optimized for Android devices.","After learning about the building blocks of Android applications, you’ll be introduced to the different types of applications you can create, and you’ll start to understand some of the design considerations that should go into developing applications for mobile devices. 44712c01.indd 17 10/20/08 4:12:24 PM 44712c01.indd 18 10/20/08 4:12:24 PM Getting Started All you need to start writing your own Android applications is a copy of the Android SDK and the Java development kit. Unless you’re a masochist, you’ll probably want a Java IDE — Eclipse is particularly well supported — to make development a little easier.Versions of the SDK, Java, and Eclipse are available for Windows, Mac OS, and Linux, so you can explore Android from the comfort of whatever OS you favor. The SDK includes an emulator for all three OS environments, and because Android applications are run on a virtual machine, there’s no advantage to developing from any particular operating system.Android code is written using Java syntax, and the core Android libraries include most of the features from the core Java APIs. Before they can be run, though, your projects are fi rst translated into Dalvik byte code. As a result, you get the benefi ts of using Java, while your applications have the advantage of running on a virtual machine optimized for Android devices.The SDK download includes all the Android libraries, full documentation, and excellent sample applications. It also includes tools to help you write and debug your applications, like the Android Emulator to run your projects and the Dalvik Debug Monitoring Service (DDMS) to help debug them."
2,"Explain why your applications can use the Content Providers offered by others, including native providers","For a more robust persistence layer, Android provides the SQLite database library. The SQLite database offers a powerful native SQL database over which you have total control. 10/20/08 4:11:20 PM Chapter 6: Data Storage, Retrieval, and Sharing Content Providers offer a generic interface to any data source. They effectively decouple the underlying data storage technique from the application layer.By default, access to all fi les, databases, and preferences is restricted to the application that created them. Content Providers offer a managed way for your applications to share private data with other applications. Hence,your applications can use the Content Providers offered by others, including native providers.","Preferences are a simple, lightweight key/value pair mechanism for saving primitive application data, most commonly a user’s application preferences. Android also provides access to the local fi lesystem, both through specialized methods and the normal Java.IO classes.For a more robust persistence layer, Android provides the SQLite database library. The SQLite database offers a powerful native SQL database over which you have total control. 10/20/08 4:11:20 PM Chapter 6: Data Storage, Retrieval, and Sharing Content Providers offer a generic interface to any data source. They effectively decouple the underlying data storage technique from the application layer.By default, access to all fi les, databases, and preferences is restricted to the application that created them. Content Providers offer a managed way for your applications to share private data with other applications. As a result, your applications can use the Content Providers offered by others, including native providers. The data persistence techniques in Android provide options for balancing speed, effi ciency, and robustness: ❑ Shared Preferences When storing the UI state, user preferences, or application settings, you want a lightweight mechanism to store a known set of values. Shared Preferences let you save groups of key/value pairs of primitive data as named preferences. Files It’s not pretty, but sometimes writing to, and reading from, fi les directly is the only way to go. Android lets you create and load fi les on the device’s internal or external media. SQLite Databases When managed, structured data is the best approach, Android offers the SQLite relational database library. Every application can create its own databases over which it has total control. Content Providers Rather than a storage mechanism in their own right, Content Providers let you expose a well-defi ned interface for using and sharing private data. You can control access to Content Providers using the standard permission system. There are two lightweight techniques for saving simple application data for Android applications — Shared Preferences and a pair of event handlers used for saving Activity instance details. Both mechanisms use a name/value pair (NVP) mechanism to store simple primitive values.Using SharedPreferences, you can create named maps of key/value pairs within your application that can be shared between application components running in the same Context."
3,"Explain why you could, for example, create an application that dynamically loads a dictionary resource based on the user’s current settings","By default, fi les created using the openFileOutput method are private to the calling application — a different application that tries to access these fi les will be denied access. The standard way to share a fi le between applications is to use a Content Provider. Alternatively, you can specify either Context.MODE_WORLD_READABLE or Context.MODE_WORLD_WRITEABLE when creating the output fi le to make them available in other applications, as shown in the following snippet: String OUTPUT_FILE = “publicCopy.txt”; FileOutputStream fos = openFileOutput(OUTPUT_FILE, Context.MODE_WORLD_WRITEABLE); Including Static Files as Resources If your application requires external fi le resources, you can include them in your distribution package by placing them in the res/raw folder of your project hierarchy. 44712c06.indd 174 10/20/08 4:11:20 PM Chapter 6: Data Storage, Retrieval, and Sharing To access these Read Only fi le resources, call the openRawResource method from your application’s Resource object to receive an InputStream based on the specifi ed resource. Pass in the fi lename (without extension) as the variable name from the R.raw class, as shown in the skeleton code below: Resources myResources = getResources(); InputStream myFile = myResources.openRawResource(R.raw.myfilename); Adding raw fi les to your resources hierarchy is an excellent alternative for large, preexisting data sources (such as dictionaries) where it’s not desirable (or even possible) to convert them into an Android database.Android’s resource mechanism lets you specify alternative resource fi les for different languages, locations, or hardware confi gurations. Hence,you could, for example, create an application that dynamically loads a dictionary resource based on the user’s current settings.","If the fi lename you specify when creating a FileOutputStream does not exist, Android will create it for you. The default behavior for existing fi les is to overwrite them; to append an existing fi le, specify the mode as Context.MODE_APPEND.By default, fi les created using the openFileOutput method are private to the calling application — a different application that tries to access these fi les will be denied access. The standard way to share a fi le between applications is to use a Content Provider. Alternatively, you can specify either Context.MODE_WORLD_READABLE or Context.MODE_WORLD_WRITEABLE when creating the output fi le to make them available in other applications, as shown in the following snippet: String OUTPUT_FILE = “publicCopy.txt”; FileOutputStream fos = openFileOutput(OUTPUT_FILE, Context.MODE_WORLD_WRITEABLE); Including Static Files as Resources If your application requires external fi le resources, you can include them in your distribution package by placing them in the res/raw folder of your project hierarchy. 44712c06.indd 174 10/20/08 4:11:20 PM Chapter 6: Data Storage, Retrieval, and Sharing To access these Read Only fi le resources, call the openRawResource method from your application’s Resource object to receive an InputStream based on the specifi ed resource. Pass in the fi lename (without extension) as the variable name from the R.raw class, as shown in the skeleton code below: Resources myResources = getResources(); InputStream myFile = myResources.openRawResource(R.raw.myfilename); Adding raw fi les to your resources hierarchy is an excellent alternative for large, preexisting data sources (such as dictionaries) where it’s not desirable (or even possible) to convert them into an Android database.Android’s resource mechanism lets you specify alternative resource fi les for different languages, locations, or hardware confi gurations. As a result, you could, for example, create an application that dynamically loads a dictionary resource based on the user’s current settings. Android supplies some basic fi le management tools to help you deal with the fi lesystem. Many of these utilities are located within the standard java.io.File package.Complete coverage of Java fi le management utilities is beyond the scope of this book, but Android does supply some specialized utilities for fi le management available from the application’s Context. deleteFile Lets you remove fi les created by the current application. fileList Returns a String array that includes all the fi les created by the current application. Android provides full relational database capabilities through the SQLite library, without imposing any additional limitations."
4,Explain why there’s no strict type checking when assigning or extracting values from each column within a row,"SQLite has a reputation of being extremely reliable and is the database system of choice for many consumer electronic devices, including several MP3 players, the iPhone, and the iPod Touch.Lightweight and powerful, SQLite differs from many conventional database engines by using a loosely typed approach to column defi nitions. Rather than requiring column values to conform to a single type, the values in each row for each column are individually typed. Hence,there’s no strict type checking when assigning or extracting values from each column within a row.","By providing functionality through a library, rather than as a separate process, each database becomes an integrated part of the application that created it. This reduces external dependencies, minimizes latency, and simplifi es transaction locking and synchronization.SQLite has a reputation of being extremely reliable and is the database system of choice for many consumer electronic devices, including several MP3 players, the iPhone, and the iPod Touch.Lightweight and powerful, SQLite differs from many conventional database engines by using a loosely typed approach to column defi nitions. Rather than requiring column values to conform to a single type, the values in each row for each column are individually typed. As a result, there’s no strict type checking when assigning or extracting values from each column within a row.For more comprehensive coverage of SQLite, including its particular strengths and limitations, check out the offi cial site at www.sqlite.org/. Cursors and Content Values ContentValues objects are used to insert new rows into database tables (and Content Providers). Each Content Values object represents a single row, as a map of column names to values."
5,"Explain why any application with the appropriate permissions can add, remove, and update data from any other applications — including some native Android databases","To provide access to your tasks for other applications to leverage, you can expose them using a Content Provider. Content Providers are a generic interface mechanism that lets you share data between applications. By abstracting away the underlying data source, Content Providers let you decouple your application layer from the data layer, making your applications data-source agnostic.Content Providers feature full permission control and are accessed using a simple URI model. Shared content can be queried for results as well as supporting write access. Hence,any application with the appropriate permissions can add, remove, and update data from any other applications — including some native Android databases.","By using a private database, your tasks are not available for other applications to view or add to them.To provide access to your tasks for other applications to leverage, you can expose them using a Content Provider. Content Providers are a generic interface mechanism that lets you share data between applications. By abstracting away the underlying data source, Content Providers let you decouple your application layer from the data layer, making your applications data-source agnostic.Content Providers feature full permission control and are accessed using a simple URI model. Shared content can be queried for results as well as supporting write access. As a result, any application with the appropriate permissions can add, remove, and update data from any other applications — including some native Android databases.Many of the native databases have been made available as Content Providers, accessible by third-party applications. This means that your applications can have access to the phone’s Contact Manager, media player, and other native database once they’ve been granted permission."
6,Explain why you can only use a MapView within MapActivity-derived Activities,"In the following sections, you’ll see how to use Overlays and the MapController to create dynamic map-based Activities. Unlike online mashups, your map Activities will run natively on the device, allowing you to leverage its hardware and mobility to provide a more customized and personal user experience. This section introduces several classes used to support Android maps: ❑ MapView is the actual Map View (control). MapActivity is the base class you extend to create a new Activity that can include a Map View. The MapActivity class handles the application life cycle and background service management required for displaying maps. Hence,you can only use a MapView within MapActivity-derived Activities.","Map Views support annotation using both Overlays and by pinning Views to geographical locations. Map Views offer full programmatic control of the map display, letting you control the zoom, location, and display modes — including the option to display satellite, street, and traffi c views.In the following sections, you’ll see how to use Overlays and the MapController to create dynamic map-based Activities. Unlike online mashups, your map Activities will run natively on the device, allowing you to leverage its hardware and mobility to provide a more customized and personal user experience. This section introduces several classes used to support Android maps: ❑ MapView is the actual Map View (control). MapActivity is the base class you extend to create a new Activity that can include a Map View. The MapActivity class handles the application life cycle and background service management required for displaying maps. As a result, you can only use a MapView within MapActivity-derived Activities. Overlay is the class used to annotate your maps. Using Overlays, you can use a Canvas to draw onto any number of layers that are displayed on top of a Map View. MapController is used to control the map, allowing you to set the center location and zoom levels. MyLocationOverlay is a special overlay that can be used to display the current position and orientation of the device. ItemizedOverlays and OverlayItems are used together to let you create a layer of map markers, displayed using drawable with associated text. To use maps in your applications, you need to create a new Activity that extends MapActivity. Within it, add a MapView to the layout to display a Google Maps interface element. The Android map library is not a standard package; as an optional API, it must be explicitly included in the application manifest before it can be used. Add the library to your manifest using a uses-library tag within the application node, as shown in the XML snippet below: <uses-library android:name=”com.google.android.maps”/> 224 44712c07.indd 224 10/20/08 4:11:05 PM Chapter 7: Maps, Geocoding, and Location-Based Services Google Maps downloads the map tiles on demand; as a result, it implicitly requires permission to use the Internet. To see map tiles in your Map View, you need to add a uses-permission tag to your application manifest for android.permission.INTERNET, as shown below: <uses-permission android:name=”android.permission.INTERNET”/> Once you’ve added the library and confi gured your permission, you’re ready to create your new map-based Activity.MapView controls can only be used within an Activity that extends MapActivity. Override the onCreate method to lay out the screen that includes a MapView, and override isRouteDisplayed to return true if the Activity will be displaying routing information (such as traffi c directions)."
7,Explain why the functionality described in this section will not be available to developers using the fi rst full release of the Android SDK,"At the end of this chapter, you’ll use the SMS Manager in a detailed project that shows how to create an emergency SMS responder. In emergency situations, it will let users quickly, or automatically, respond to people asking after their safety. 10/20/08 4:10:35 PM Chapter 9: Peer-to-Peer Communication Introducing Android Instant Messaging Largely as a result of security concerns, developer access to the GTalk IM Service has been restricted for Android SDK version 1.0. Hence,the functionality described in this section will not be available to developers using the fi rst full release of the Android SDK.","Android still offers full access to SMS functionality, letting you send and receive SMS text messages within your applications. Using the Android APIs, you can create your own SMS client application to replace the native applications available as part of the software stack. Alternatively, you can incorporate the messaging functionality within your own applications.At the end of this chapter, you’ll use the SMS Manager in a detailed project that shows how to create an emergency SMS responder. In emergency situations, it will let users quickly, or automatically, respond to people asking after their safety. 10/20/08 4:10:35 PM Chapter 9: Peer-to-Peer Communication Introducing Android Instant Messaging Largely as a result of security concerns, developer access to the GTalk IM Service has been restricted for Android SDK version 1.0. As a result, the functionality described in this section will not be available to developers using the fi rst full release of the Android SDK.Rather than remove the affected sections, they have been left here in full as a guide for use with future Android releases."
8,Explain why the following code snippet shows a more typical implementation of the ServiceConnection used to bind the GTalk Service to an application,"You can create several different connections and multiple IM Sessions connecting to different GTalk servers or IM providers. Session that uses the device owner’s username. You can access the default connection and session using getDefaultConnection and getDefaultSession on the GTalk Service and default connection, respectively, as shown in the snippet below: IGTalkConnection gTalkConnection = gtalkService.getDefaultConnection(); IImSession imSession = gTalkConnection.getDefaultImSession(); IM Sessions are used to send text and data messages, set user presence, manage the IM contact roster, and manage group chats.The IM Session is your primary interface for handling instant messaging in Android applications. Hence,the following code snippet shows a more typical implementation of the ServiceConnection used to bind the GTalk Service to an application.","Before you can use the Service to use Android’s Instant Messaging functionality, you need to initiate a new GTalkConnection, as shown in the following section. A GTalk Connection represents a conduit between the device and a GTalk server. An IM Session is the message pathway used to handle all the instant message traffi c; all the instant messages for a given session fl ow through this pipe.You can create several different connections and multiple IM Sessions connecting to different GTalk servers or IM providers. Session that uses the device owner’s username. You can access the default connection and session using getDefaultConnection and getDefaultSession on the GTalk Service and default connection, respectively, as shown in the snippet below: IGTalkConnection gTalkConnection = gtalkService.getDefaultConnection(); IImSession imSession = gTalkConnection.getDefaultImSession(); IM Sessions are used to send text and data messages, set user presence, manage the IM contact roster, and manage group chats.The IM Session is your primary interface for handling instant messaging in Android applications. As a result, the following code snippet shows a more typical implementation of the ServiceConnection used to bind the GTalk Service to an application. It ensures that an IM Session object is always valid. private IImSession imSession = null; private ServiceConnection gTalkServiceConnection = new ServiceConnection() { // When the service connects, get the default GTalk session. IGTalkService gtalkService = IGTalkService.Stub.asInterface(service); try { gTalkConnection = gtalkService.getDefaultConnection(); imSession = gTalkConnection.getDefaultImSession(); } catch (RemoteException e) { } 282 44712c09.indd 282 10/20/08 4:10:35 PM Chapter 9: Peer-to-Peer Communication } // When the service disconnects, clear the GTalk session. gTalkConnection = null; imSession = null; } }; Introducing Presence and the Contact Roster Presence is a lightweight mechanism used in instant messaging to broadcast a user’s availability.Originally, presence was represented as a simple fl ag that indicated when a user was logged on and available to chat. This has gradually evolved into a more detailed status indicator that lets users describe their availability more accurately by indicating if they’re available, busy, away from the computer, or offl ine. The recent popularity of applications like FriendFeed and Twitter has resulted in presence being expanded to include custom messages that can describe anything from a user’s current activity to the music they’re listening to."
9,Explain why the multimedia capabilities of portable devices are a signifi cant consideration for many consumers,"You’ll also learn how to monitor hardware sensors using the Sensor Manager. The accelerom- eter and compass sensors will be used to determine changes in the device orientation and acceleration — which is extremely useful for creating motion-based User Interfaces — and lets you add new dimensions to your location-based applications.Finally, you’ll take a closer look at the communication hardware by examining the telephony package for monitoring phone state and phone calls, as well as seeing what’s available in the Bluetooth, networking, and Wi-Fi APIs. 10/20/08 4:10:17 PM Chapter 10: Accessing Android Hardware Using the Media APIs The only modern technology that can compete with mobile phones for ubiquity is the portable digital media player. Hence,the multimedia capabilities of portable devices are a signifi cant consideration for many consumers.","In this chapter, you’ll take a closer look at some of these hardware APIs. In particular, you’ll learn how to play and record multimedia content including audio, video, and still images, as well as use the camera to capture images and preview and capture live video.You’ll also learn how to monitor hardware sensors using the Sensor Manager. The accelerom- eter and compass sensors will be used to determine changes in the device orientation and acceleration — which is extremely useful for creating motion-based User Interfaces — and lets you add new dimensions to your location-based applications.Finally, you’ll take a closer look at the communication hardware by examining the telephony package for monitoring phone state and phone calls, as well as seeing what’s available in the Bluetooth, networking, and Wi-Fi APIs. 10/20/08 4:10:17 PM Chapter 10: Accessing Android Hardware Using the Media APIs The only modern technology that can compete with mobile phones for ubiquity is the portable digital media player. As a result, the multimedia capabilities of portable devices are a signifi cant consideration for many consumers.Android’s open platform- and provider-agnostic philosophy ensures that it offers a multimedia library capable of playing and recording a wide range of media formats, both locally and streamed."
10,"Explain why it’s good practice to use the Media Store Content Provider to assign metadata, select a fi le location, and publish the recorded media to share recordings with other applications","To begin recording, call prepare followed by the start method, as shown below: mediaRecorder.prepare(); mediaRecorder.start(); When you’re fi nished, call stop to end the playback, followed by release to free the Media Recorder resources: mediaRecorder.stop(); mediaRecorder.release(); When recording video, it’s generally considered good practice to display a preview of the recorded video in real time. Using the setPreviewDisplay method, you can assign a Surface to display the video preview.As with any other resource, media fi les created by your application will be unavailable to others. Hence,it’s good practice to use the Media Store Content Provider to assign metadata, select a fi le location, and publish the recorded media to share recordings with other applications.","The following code snippet shows how to confi gure a Media Recorder to record audio from the microphone using the default format and encoder: The emulator supports recording of audio using the microphone device attached to your development platform. // Set the output format. // Set the audio encoders to use. Once you’ve defi ned your input source and output format, assign a fi le to store the recorded media using the setOutputFile method as shown below: mediaRecorder.setOutputFile(“myoutputfile.mp4”); The setOutputFile method must be called before prepare and after setOutputFormat or it will throw an Illegal State Exception.To begin recording, call prepare followed by the start method, as shown below: mediaRecorder.prepare(); mediaRecorder.start(); When you’re fi nished, call stop to end the playback, followed by release to free the Media Recorder resources: mediaRecorder.stop(); mediaRecorder.release(); When recording video, it’s generally considered good practice to display a preview of the recorded video in real time. Using the setPreviewDisplay method, you can assign a Surface to display the video preview.As with any other resource, media fi les created by your application will be unavailable to others. As a result, it’s good practice to use the Media Store Content Provider to assign metadata, select a fi le location, and publish the recorded media to share recordings with other applications.To do that, after recording new media create a new ContentValues object to add a new record to the Media Store. The metadata you specify here can include the details including the title, time stamp, and geocoding information for your new media fi le, as shown in the code snippet below: ContentValues content = new ContentValues(3); content.put(Audio.AudioColumns.TITLE, “TheSoundandtheFury”); 318 44712c10.indd 318 10/20/08 4:10:17 PM Chapter 10: Accessing Android Hardware content.put(Audio.AudioColumns.DATE_ADDED, System.currentTimeMillis() / 1000); content.put(Audio.Media.MIME_TYPE, “audio/amr”); You must also specify the absolute path of the media fi le being added: content.put(MediaStore.Audio.Media.DATA, “myoutputfile.mp4”); Get access to the application’s ContentResolver, and use it to insert this new row into the Media Store as shown in the following code snippet: ContentResolver resolver = getContentResolver(); Uri uri = resolver.insert(Audio.Media.EXTERNAL_CONTENT_URI, content); Once the media fi le has been inserted into the media store you should announce it’s availability using a broadcast Intent as shown below: sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, uri)); Using the Camera The popularity of digital cameras (particularly within phone handsets) has caused their prices to drop just as their size has shrunk dramatically. It’s now becoming diffi cult to even fi nd a mobile phone without a camera, and Android devices are unlikely to be exceptions."
11,Explain why an accelerometer detecting acceleration on the Z-axis (up/down) will read –9,"Generally, you’ll be interested in acceleration changes relative to a rest state, or rapid movement (signifi ed by rapid changes in acceleration) such as gestures used for user input. In the former case, you’ll often need to calibrate the device to calculate the initial orientation and acceleration to take those effects into account in future results.Accelerometers are unable to differentiate between acceleration due to movement and gravity. Hence,an accelerometer detecting acceleration on the Z-axis (up/down) will read –9.","It’s important to note that accelerometers do not measure velocity, so you can’t measure speed directly based on a single accelerometer reading. Instead, you need to measure changes in acceleration over time.Generally, you’ll be interested in acceleration changes relative to a rest state, or rapid movement (signifi ed by rapid changes in acceleration) such as gestures used for user input. In the former case, you’ll often need to calibrate the device to calculate the initial orientation and acceleration to take those effects into account in future results.Accelerometers are unable to differentiate between acceleration due to movement and gravity. As a result, an accelerometer detecting acceleration on the Z-axis (up/down) will read –9.8 m/s2 when it’s at rest (this value is available as the SensorManager.STANDARD_GRAVITY constant). Acceleration can be measured along three directional axes: forward–backward (longitudinal), left–right (lateral), and up–down (vertical). The Sensor Manager reports sensor changes in all three directions (as illustrated in Figure 10-1): Y X Z Figure 10-1 324 44712c10.indd 324 10/20/08 4:10:17 PM Chapter 10: Accessing Android Hardware ❑ Vertical Upward or downward, where positive represents upward movement such as the device being lifted up. Longitudinal Forward or backward acceleration, where forward acceleration is positive. This represents a device fl at on its back, facing up, and in portrait orientation being moved along the desk in the direction of the top of the device. Lateral Sideways (left or right) acceleration, where positive values represent movement toward the right of the device, and negative values show movement toward the left. In the same confi guration as described in longitudinal movement, positive lateral movement would be created by moving the device along the surface to your right.The Sensor Manager considers the device “at rest” when it is sitting face up on a fl at surface in portrait orientation."
12,"Explain why for bidirectional communication, two socket connections must be established","In practice, this alphabet soup provides a mechanism for opening communication sockets between two paired Bluetooth devices.In order for an RFCOMM communication channel to be established, a listening port on one device must be connected to an outgoing port on the other. Hence,for bidirectional communication, two socket connections must be established.","Bluetooth data transfer is handled using the RfcommSocket class, which provides a wrapper for the Bluetooth radiofrequency communications (RFCOMM) protocol that supports RS232 serial communication over an underlying Logical Link Control and Adaptation Protocol (L2CAP) layer.In practice, this alphabet soup provides a mechanism for opening communication sockets between two paired Bluetooth devices.In order for an RFCOMM communication channel to be established, a listening port on one device must be connected to an outgoing port on the other. As a result, for bidirectional communication, two socket connections must be established. Before you can transfer data between Bluetooth devices, you need to open a new RFCommSocket.Start by creating a new RFCommSocket object and calling its create method. This constructs a new socket for you to use on your Bluetooth device, returning a FileDescriptor for transferring data."
13,Explain why all of the advanced features described so far in this section can be used to enhance map Overlays,"All that’s left is to draw two more circles as clean borders for the inner and outer face boundaries. Then restore the canvas to upright, and fi nish the onDraw method. canvas.drawOval(boundingBox, circlePaint); // Draw the inner ring circlePaint.setStrokeWidth(2); canvas.drawOval(innerBoundingBox, circlePaint); canvas.restore(); } Bringing Map Overlays to Life In Chapter 7, you learned how to use Overlays to add annotation layers to MapViews. The Canvas used for annotating MapView Overlays is the same class as the one used to draw new View controls. Hence,all of the advanced features described so far in this section can be used to enhance map Overlays.","Start by adding a “glass dome” over the top to give the illusion of a watch face. Using the radial gradient array you constructed earlier, create a new Shader and Paint object. Use them to draw a circle over the inner face that makes it look like it’s covered in glass. (int)innerRadius, 388 44712c11.indd 388 10/20/08 4:09:58 PM Chapter 11: Advanced Android Development glassGradientColors, glassGradientPositions, TileMode.CLAMP); Paint glassPaint = new Paint(); glassPaint.setShader(glassShader); canvas.drawOval(innerBoundingBox, glassPaint); 18.All that’s left is to draw two more circles as clean borders for the inner and outer face boundaries. Then restore the canvas to upright, and fi nish the onDraw method. canvas.drawOval(boundingBox, circlePaint); // Draw the inner ring circlePaint.setStrokeWidth(2); canvas.drawOval(innerBoundingBox, circlePaint); canvas.restore(); } Bringing Map Overlays to Life In Chapter 7, you learned how to use Overlays to add annotation layers to MapViews. The Canvas used for annotating MapView Overlays is the same class as the one used to draw new View controls. As a result, all of the advanced features described so far in this section can be used to enhance map Overlays.That means you can use any of the draw methods, transparency, Shaders, Color Masks, and Filter Effects to create rich Overlays using the Android graphics framework. Touch-screen interaction in MapViews is handled individually by each of its Overlays. To handle map taps within an Overlay, override the onTap event."
