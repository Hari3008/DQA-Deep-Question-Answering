,Question,Answer,Context
0,Explain why you can use the same AVD for multiple applications,"There are a number of other files saved on disk as part of the Eclipse project in the workspace. However, the files included in Table 3.1 are the important project files you will use on a regular basis. The next step is to create an AVD that describes what type of device you want to emulate when running the application. For this example, we can use the AVD we created for the Snake application. An AVD describes a device, not an application Hence,you can use the same AVD for multiple applications.","7. Check the Create Activity checkbox.This instructs the wizard to create a default launch activity for the application. Call this Activity class MyFirstAndroidAppActivity. Every Android application has a set of core files that are created and are used to define the functionality of the application (see Table 3.1).The following files are created by default with a new Android application. 51 Figure 3.8 Configuring My First Android App using the Android Project Wizard.There are a number of other files saved on disk as part of the Eclipse project in the workspace. However, the files included in Table 3.1 are the important project files you will use on a regular basis. The next step is to create an AVD that describes what type of device you want to emulate when running the application. For this example, we can use the AVD we created for the Snake application. An AVD describes a device, not an application.Therefore, you can use the same AVD for multiple applications.You can also create similar AVDs with the same configuration, but different data (such as different applications installed and different SD card contents). Again, for more information on creating different types of AVDs and working with the Android emulator, check out Appendix A, “The Android Emulator Quick-Start Guide.” 52 Chapter 3 Writing Your First Android Application Table 3.1 Important Android Project Files and Directories Android File General Description AndroidManifest.xml Global application description file. It defines your application’s capabilities and permis- sions and how it runs. Automatically created project file. It defines your application’s build target and other build system options, as required. Required folder where all source code for the application resides. Core source file that defines the entry point androidapp/MyFirstAndroidApp- of your Android application. gen Folder Required folder where auto-generated re- source files for the application reside. Application resource management source file androidapp/R.java generated for you; it should not be edited. Required folder where all application re- sources are managed. Application resources include animations, drawable image assets, layout files, XML files, data resources such as strings, and raw files. Resource folders that store different resolu- tions of the application icon. Single screen layout file. Application string resources. Folder where all application assets are stored. Application assets are pieces of ap- plication data (files, directories) that you do not want managed as application resources. Next, you must create a Run and Debug launch configuration in Eclipse to configure the circumstances under which the MyFirstAndroidApp application builds and launches.The launch configuration is where you configure the emulator options to use and the entry point for your application. ent options for each. Begin by creating a Run Configuration for the application. application: 1. Choose Run, Run Configurations (or right-click the Project and Choose Run As). 53 2. Double-click Android Application. droidApp project.5. Switch to the Target tab and set the Device Target Selection Mode to Manual. If you leave the Device Target Selection mode on Automatic when you choose Run or Debug in Eclipse, your application is automatically installed and run on the device if the device is plugged in. Otherwise, the application starts in the emulator with the specified AVD. By choosing Manual, you are always prompted for whether (a) you want your application to be launched in an existing emulator; (b) you want your application to be launched in a new emulator instance and allowed to specify an AVD; or (c) you want your application to be launched on the device (if it’s plugged in). If any emulator is already running, the device is then plugged in, and the mode is set to Automatic, you see this same prompt, too."
1,Explain why an Intent is basically saying “do this” (the action) to “that” (the Uri describing what resource to do the action to),"The guts of the Intent object are composed of two main parts: the action to be performed and the data to be acted upon.You can also specify action/data pairs using Intent Action types and Uri objects. As you saw in Chapter 3, “Writing Your First Android Application,” a Uri object represents a string that gives the location and name of an object. Hence,an Intent is basically saying “do this” (the action) to “that” (the Uri describing what resource to do the action to).","For now, though, we focus on Intents and how they are used with Activities.The fol- lowing line of code calls the startActivity() method with an explicit Intent.This Intent requests the launch of the target Activity named MyDrawActivity by its class. MyDrawActivity.class)); Performing Application Tasks with Activities 77 This line of code might be sufficient for some applications, which simply transition from one Activity to the next. However, you can use the Intent mechanism in a much more robust manner. For example, you can use the Intent structure to pass data between Activities. You’ve seen the simplest case to use an Intent to launch a class by name. Intents need not specify the component or class they want to launch explicitly. Instead, you can create an Intent Filter and register it within the Android Manifest file.The Android operating system attempts to resolve the Intent requirements and launch the appropriate Activity based on the filter criteria.The guts of the Intent object are composed of two main parts: the action to be performed and the data to be acted upon.You can also specify action/data pairs using Intent Action types and Uri objects. As you saw in Chapter 3, “Writing Your First Android Application,” a Uri object represents a string that gives the location and name of an object.Therefore, an Intent is basically saying “do this” (the action) to “that” (the Uri describing what resource to do the action to). ACTION_MAIN (describes the main entry point of an Activity) and ACTION_EDIT (used in conjunction with a Uri to the data edited).You also find Action types that generate integration points with Activities in other applications, such as the Browser or Phone Dialer. Initially, your application might be starting only Activities defined within its own package.However, with the appropriate permissions, applications might also launch external Activities within other applications. For example, a Customer Relationship Management (CRM) application might launch the Contacts application to browse the Contact data- base, choose a specific contact, and return that Contact’s unique identifier to the CRM application for use. (ACTION_DIAL) to launch the Phone Dialer with a specific phone number to dial in the form of a simple Uri object: Uri number = Uri.parse(tel:5555551212); Intent dial = new Intent(Intent.ACTION_DIAL, number); startActivity(dial); You can find a list of commonly used Google application Intents at http://developer.an- droid.com/guide/appendix/g-app-intents.html. Also available is the developer managed Registry of Intents protocols at OpenIntents, found at http://www.openintents.org/en/ intentstable, which has a growing list of Intents available from third-party applications and those within the Android SDK. Chapter 4 Understanding the Anatomy of an Android Application Passing Additional Information Using Intents You can also include additional data in an Intent.The Extras property of an Intent is stored in a Bundle object.The Intent class also has a number of helper methods for getting and setting name/value pairs for many common datatypes. string value and a boolean: Intent intent = new Intent(this, MyActivity.class); intent.putExtra(“SomeStringData”,”Foo”); intent.putExtra(“SomeBooleanData”,false); Tip The strings you use to identify your Intent object extras can be whatever you want. However, the Android convention for the key name for “extra” data is to include a package prefix—for example, com.androidbook.Multimedia.SomeStringData. As previously mentioned, your application likely has a number of screens, each with its own Activity.There is a close relationship between menus, Activities, and Intents.You often see a menu used in two different ways with Activities and Intents: n Main Menu: Acts as a switch in which each menu item launches a different Activity in your application. For instance, menu items for launching the Play Game Activity, the High Scores Activity, and the Help Activity. Drill-Down: Acts as a directory in which each menu item launches the same Activity, but each item passes in different data as part of the Intent (for example, a menu of all database records). Choosing a specific item might launch the Edit Record Activity, passing in that particular item’s unique identifier. Trying to wrap your head around Activities, Intents, Intent Filters, and the lot when you start with Android development can be daunting.We have tried to distill everything you need to know to start writing Android applications with multiple Activity classes, but we’d be remiss if we didn’t mention that there’s a lot more here, much of which is discussed throughout the book using practical examples. However, we need to give you a “heads up” about some of these topics now because we talk about these concepts very soon when we cover configuring the Android Manifest file for your application in the next chapter. Activity without a user interface. It can run as a background process or act much like a web service does, processing requests from third parties.You can use Intents and Activities Receiving and Broadcasting Intents 79 to launch services using the startService() and bindService() methods.Any Services exposed by an Android application must be registered in the Android Manifest file."
2,"Explain why add the following to your Android Manifest file within the <manifest> tag block: <uses-sdk android:minSdkVersion=""4"" /> It’s that simple","Instead, it is the revision of the API level associated with that SDK.The API level is set by the developers of the Android SDK.You need to check the SDK documentation to determine the API level value for each version. With each new Android SDK version, this API level is incremented. This information is always provided with the SDK release documentation. Android SDK Versions and Their API Levels Android SDK Version API Level (Value as Integer) Android 1.0 SDK 1 Android 1.1 SDK 2 Android 1.5 SDK (Cupcake) 3 Android 1.6 SDK (Donut) 4 Android 2.0 SDK (Éclair) 5 Android 2.0.1 SDK (Éclair) 6 Android 2.1 SDK (Éclair) 7 Enforcing Application System Requirements 89 Table 5.1 Android SDK V Continued ersions and Their API Levels Android SDK Version API Level (Value as Integer) Android 2.2 SDK (FroYo) 8 Android SDK (Gingerbread) 9 Specifying the Minimum SDK Version You should always specify the minSdkVersion attribute for your application.This value represents the lowest Android SDK version your application supports. would check that SDK’s documentation and find that this release is defined as API Level 4 Hence,add the following to your Android Manifest file within the <manifest> tag block: <uses-sdk android:minSdkVersion=""4"" /> It’s that simple.","Each attribute of the <uses-sdk> tag is an integer that represents the API level associated with a given Android SDK.This value does not directly correspond to the SDK version.Instead, it is the revision of the API level associated with that SDK.The API level is set by the developers of the Android SDK.You need to check the SDK documentation to determine the API level value for each version. With each new Android SDK version, this API level is incremented. This information is always provided with the SDK release documentation. Android SDK Versions and Their API Levels Android SDK Version API Level (Value as Integer) Android 1.0 SDK 1 Android 1.1 SDK 2 Android 1.5 SDK (Cupcake) 3 Android 1.6 SDK (Donut) 4 Android 2.0 SDK (Éclair) 5 Android 2.0.1 SDK (Éclair) 6 Android 2.1 SDK (Éclair) 7 Enforcing Application System Requirements 89 Table 5.1 Android SDK V Continued ersions and Their API Levels Android SDK Version API Level (Value as Integer) Android 2.2 SDK (FroYo) 8 Android SDK (Gingerbread) 9 Specifying the Minimum SDK Version You should always specify the minSdkVersion attribute for your application.This value represents the lowest Android SDK version your application supports. would check that SDK’s documentation and find that this release is defined as API Level 4.Therefore, add the following to your Android Manifest file within the <manifest> tag block: <uses-sdk android:minSdkVersion=""4"" /> It’s that simple.You should use the lowest API level possible if you want your application to be compatible with the largest number of Android handsets. However, you must ensure that your application is tested sufficiently on any non-target platforms (any API level supported below your target SDK, as described in the next section). You should always specify the targetSdkVersion attribute for your application.This value represents the Android SDK version your application was built for and tested against.For example, if your application was built using the APIs that are backward-compatible to Android 1.6 (API Level 4), but targeted and tested using Android 2.2 SDK (API Level 8), then you would want to specify the targetSdkVersion attribute as 8.Therefore, add the following to your Android manifest file within the <manifest> tag block: <uses-sdk android:minSdkVersion=""4"" android:targetSdkVersion=""8"" /> Why should you specify the target SDK version you used? Well, the Android platform has built-in functionality for backward-compatibility (to a point).Think of it like this: A specific method of a given API might have been around since API Level 1. However, the internals of that method—its behavior—might have changed slightly from SDK to SDK."
3,"Explain why if you create an alternative layout resource, make sure each important control exists in the layout and is named the same","If you save the layout file and run the application in the emulator (see Figure 6.5) or on the phone, you see results much like you did in the resource designer preview pane. Layouts, whether they are Button or ImageView controls, are all derived from the View class. Here’s how you would retrieve a TextView object named TextView01: TextView txt = (TextView)findViewById(R.id.TextView01); You can also access the underlying XML of a layout resource much as you would any XML file.The following code retrieves the main.xml layout file for XML parsing: XmlResourceParser myMainXml = getResources().getLayout(R.layout.main); Working with Resources 127 Figure 6.5 A layout with a LinearLayout, TextView, and ImageView, shown in the Android emulator. about layout files and designing Android user interfaces in Chapter 8,“Designing User Interfaces with Layouts.” Warning Take care when providing alternative layout resources. Layout resources tend to be complicated, and the child controls within them are often referred to in code by name. Hence,if you create an alternative layout resource, make sure each important control exists in the layout and is named the same.","Now, you see that the graphic shows up in your preview.While we’re at it, select the LinearLayout object and set its background property to the background Drawable you added.If you save the layout file and run the application in the emulator (see Figure 6.5) or on the phone, you see results much like you did in the resource designer preview pane. Layouts, whether they are Button or ImageView controls, are all derived from the View class. Here’s how you would retrieve a TextView object named TextView01: TextView txt = (TextView)findViewById(R.id.TextView01); You can also access the underlying XML of a layout resource much as you would any XML file.The following code retrieves the main.xml layout file for XML parsing: XmlResourceParser myMainXml = getResources().getLayout(R.layout.main); Working with Resources 127 Figure 6.5 A layout with a LinearLayout, TextView, and ImageView, shown in the Android emulator. about layout files and designing Android user interfaces in Chapter 8,“Designing User Interfaces with Layouts.” Warning Take care when providing alternative layout resources. Layout resources tend to be complicated, and the child controls within them are often referred to in code by name. Therefore, if you create an alternative layout resource, make sure each important control exists in the layout and is named the same. For example, if both layouts have a Button control, make sure its identifier (android:id) is the same in both the landscape and portrait mode alternative layout resources. You may include different controls in the layouts, but the important ones (those referred to and interacted with programmatically) should match in both layouts. Android user interface designers can group layout element attributes together in styles.Layout controls are all derived from the View base class, which has many useful attributes."
4,"Explain why you could have one or more layouts (such as a LinearLayout with two child controls—a TextView and an ImageView) defined within a layout resource file, such as /res/layout/myScreen","In terms of resources, the /res/layout directory contains XML resource definitions often called layout resource files. These XML files provide a template for how to draw to a screen; layout resource files may contain any number of views. We talk about layout resources in Chapter 6, “Managing Application Resources.” Creating User Interfaces in Android 175 The term layout is also used to refer to a set of ViewGroup classes such as LinearLayout, FrameLayout, TableLayout, and RelativeLayout. These layout classes are used to organize View controls. We talk more about these classes later in this chapter. Hence,you could have one or more layouts (such as a LinearLayout with two child controls—a TextView and an ImageView) defined within a layout resource file, such as /res/layout/myScreen.","Creating only an XML file, though, won’t actually draw anything on the screen. A par- ticular layout is usually associated with a particular Activity. In your default Android project, there is only one activity, which sets the main.xml layout by default.To associate the main.xml layout with the activity, use the method call setContentView() with the identifier of the main.xml layout.The ID of the layout matches the XML filename with- out the extension. In this case, the preceding example came from main.xml, so the identifier of this layout is simply main: setContentView(R.layout.main); Tip Although it’s a tad confusing, the term layout is used for two different (but related) purposes in Android development.In terms of resources, the /res/layout directory contains XML resource definitions often called layout resource files. These XML files provide a template for how to draw to a screen; layout resource files may contain any number of views. We talk about layout resources in Chapter 6, “Managing Application Resources.” Creating User Interfaces in Android 175 The term layout is also used to refer to a set of ViewGroup classes such as LinearLayout, FrameLayout, TableLayout, and RelativeLayout. These layout classes are used to organize View controls. We talk more about these classes later in this chapter.Therefore, you could have one or more layouts (such as a LinearLayout with two child controls—a TextView and an ImageView) defined within a layout resource file, such as /res/layout/myScreen.xml. You can create user interface components such as layouts at runtime programmatically, but for organization and maintainability, it’s best that you leave this for the odd case rather than the norm.The main reason is because the creation of layouts programmatically is onerous and difficult to maintain, whereas the XML resource method is visual, more organized, and could be done by a separate designer with no Java skills. The code examples provided in this section are taken from the SameLayout application. This source code for the SameLayout application is provided for download on the book website. LinearLayout view and place two TextView objects within it. No resources whatsoever are used; actions are done at runtime instead. super.onCreate(savedInstanceState); TextView text1 = new TextView(this); text1.setText(“Hi there!”); TextView text2 = new TextView(this); text2.setText(“I’m second. I need to wrap.”); text2.setTextSize((float) 60); LinearLayout ll = new LinearLayout(this); ll.setOrientation(LinearLayout.VERTICAL); ll.addView(text1); ll.addView(text2); setContentView(ll); } The onCreate() method is called when the Activity is created.The first thing this method does is some normal Activity housekeeping by calling the constructor for the base class. set using the setText() method. All TextView attributes, such as TextSize, are set by 176 Chapter 8 Designing User Interfaces with Layouts making method calls on the TextView object.These actions perform the same function that you have in the past by setting the properties Text and TextSize using the Eclipse layout resource designer, except these properties are set at runtime instead of defined in the layout files compiled into your application package. The XML property name is usually similar to the method calls for getting and setting that same control property programmatically. For instance, android:visibility maps to the methods setVisibility() and getVisibility(). In the preceding example TextView, the methods for getting and setting the TextSize property are getTextSize() and setTextSize(). container of some sort (a layout). In this case, we use a LinearLayout with the orientation set to VERTICAL so that the second TextView begins beneath the first, each aligned to the left of the screen.The two TextView controls are added to the LinearLayout in the order we want them to display.Finally, we call the setContentView() method, part of your Activity class, to draw the LinearLayout and its contents on the screen."
5,"Explain why we start with the “manual” method so that we can review the steps necessary to set up, draw, and tear down OpenGL ES correctly","In this chapter, we give examples of both of these methods. Although the second method (using GLSurfaceView) is indeed simpler, you gain a more complete under- standing of the fundamentals of Android OpenGL ES by following along as we describe the “manual” way first. In addition, many developers will be porting their code over from a platform where they normally go through this configuration and might have the need to customize many pieces Hence,we start with the “manual” method so that we can review the steps necessary to set up, draw, and tear down OpenGL ES correctly.","Calls are made into a user-defined Renderer class.The Renderer class handles the drawing and GL initialization and is run outside of the UI thread.In this chapter, we give examples of both of these methods. Although the second method (using GLSurfaceView) is indeed simpler, you gain a more complete under- standing of the fundamentals of Android OpenGL ES by following along as we describe the “manual” way first. In addition, many developers will be porting their code over from a platform where they normally go through this configuration and might have the need to customize many pieces.Therefore, we start with the “manual” method so that we can review the steps necessary to set up, draw, and tear down OpenGL ES correctly.The concepts and classes used for both methods are very similar, though, making this discussion useful even if you choose to use only the included GLSurfaceView method for your projects. Many of the code examples provided in this chapter are taken from the SimpleOpenGL application. The source code for this application is provided for download on the book website. We have provided a custom implementation leveraging OpenGL without using GLSurfaceView for users who need to develop for Android versions previous to Android 1.5 or who have a need for tighter control of the rendering pipeline and initialization.The following steps to initialize OpenGL ES enable you to start drawing on the screen via the OpenGL interface: 1. Initialize SurfaceView with a surface of type SURFACE_TYPE_GPU."
6,Explain why you might want to reuse or update notifications to keep the notification list manageable,"The notification displays as an icon and ticker text showing up on the status bar.This is shown at the top of Figure 20.1. Status bar notification showing an icon and ticker text. 427 Shortly after the ticker text displays, the status bar returns to normal with each notification icon shown. If the users expand the status bar, they see something like what is shown in Figure 20.2. Expanded status bar showing the icon, both text fields, and the time of the notification. You don’t want your application’s notifications piling up in the notification bar Hence,you might want to reuse or update notifications to keep the notification list manageable.","Developers can enhance their applications by using notifications from their applications to inform the user of important events. For example, an application might want to send a simple notification to the user whenever new content has been downloaded. A simple notification has a number of important components: n An icon (appears on status bar and full notification) n Ticker text (appears on status bar) n Notification title text (appears in full notification) n Notification body text (appears in full notification) n An intent (launches if the user clicks on the full notification) In this section, you learn how to create this basic kind of notification. Many of the code examples provided in this chapter are taken from the SimpleNotifica- tions application. The source code for this application is provided for download on the book website. 425 Using the NotificationManager Service All notifications are created with the help of the NotificationManager.The NotificationManager (within the android.app package) is a system service that must be requested.The following code demonstrates how to obtain a valid NotificationManager object using the getSystemService() method: NotificationManager notifier = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); The NotificationManager is not useful without having a valid Notification object to use with the notify() method.The Notification object defines what information dis- plays to the user when the Notification is triggered.This includes text that displays on the status bar, a couple of lines of text that display on the expanded status bar, an icon displayed in both places, a count of the number of times this Notification has been triggered, and a time for when the last event that caused this Notification took place. You can set the icon and ticker text, both of which display on the status bar, through the constructor for the Notification object, as follows: Notification notify = new Notification( R.drawable.android_32, ""Hello!"", System.currentTimeMillis()); Additionally, you can set notification information through public member variable assignment, like this: notify.icon = R.drawable.android_32; notify.tickerText = ""Hello!""; notify.when = System.currentTimeMillis(); You need to set a couple more pieces of information before the call to the notify() method takes place. First, we need to make a call to the setLastEventInfo() method, which configures a View that displays in the expanded status bar. Here is an example: Intent toLaunch = new Intent (SimpleNotificationsActivity.this, SimpleNotificationsActivity.class); PendingIntent intentBack = PendingIntent.getActivity (SimpleNotificationsActivity.this, 0, toLaunch, 0); notify.setLatestEventInfo(SimpleNotificationsActivity.this, ""Hi there!"", ""This is even more text."", intentBack); Next, use the notify() method to supply the notification’s title and body text as well as the Intent triggered when the user clicks on the notification. In this case, we’re using our own Activity so that when the user clicks on the notification, our Activity launches again. Chapter 20 Working with Notifications Note When the expanded status bar is pulled down, the current Activity lifecycle is still treated as if it were the top (displayed) Activity. Triggering system notifications while running in the foreground, though, isn’t particularly useful. An application that is in the foreground would be better suited using a Dialog or Toast to notify the user, not by using notifications. Now the application is ready to actually notify the user of the event. All that is needed is a call to the notify() method of the NotificationManager with an identifier and the Notification we configured.This is demonstrated with the following code: private static final int NOTIFY_1 = 0x1001; // ... notifier.notify(NOTIFY_1, notify); The identifier matches up a Notification with any previous Notification instances of that type.When the identifiers match, the old Notification is updated instead of creating a new one.You might have a Notification that some file is being downloaded.You could update the Notification when the download is complete, instead of filling the Notification queue with a separate Notification, which quickly becomes obsolete.The notification displays as an icon and ticker text showing up on the status bar.This is shown at the top of Figure 20.1. Status bar notification showing an icon and ticker text. 427 Shortly after the ticker text displays, the status bar returns to normal with each notification icon shown. If the users expand the status bar, they see something like what is shown in Figure 20.2. Expanded status bar showing the icon, both text fields, and the time of the notification. You don’t want your application’s notifications piling up in the notification bar.Therefore, you might want to reuse or update notifications to keep the notification list manageable.For example, there is no reason to keep a notification informing the user that the application is downloading File X when you now want to send another notification saying File X has finished downloading. Instead, you can simply update the first notification with new information."
7,Explain why we use a size of ((74*2)-2) or 146,"If your widget must break this limit, which you should only do for a very good reason, you must implement the timer yourself. Keep in mind the effect on battery life and performance this decision might have. guidelines.The Home screen is divided into cells of a particular size.When the user attempts to install an App Widget, the system checks to make sure there is enough space (as dictated by the minimum width and height values of the App Widget). The basic formula for determining the size of your App Widget is to multiply the number of cells you want by 74, and then subtract two. In our case, we want an App Widget two cells high and two cells wide. Hence,we use a size of ((74*2)-2) or 146.","Although App Widgets are small in size and light on functionality, they allow the user access to application functionality straight from the Home screen. App Widgets also serve to keep users using the application, by reminding them that they installed it. Some applications allow only one instance of an App Widget to run (such as the music player), whereas others might allow multiple instances of the same App Widget to be placed simultaneously, though generally showing different content (such as a picture frame). Widgets: n Provide an XML App Widget configuration. Determine whether the App Widget requires a configuration activity. Provide an AppWidgetProvider class implementation. Provide a Service class implementation to handle App Widget content updates, as needed. Update the application Android manifest file to register the App Widget provider information, as well as any information about the update service. The code examples provided in this section are taken from the SimpleAppWidget application. First, your application must provide an XML App Widget definition.You can store this definition within the project’s resources in the /res/xml directory. Let’s take a closer look at an example of an App Widget definition, as defined in /res/xml/simple_widget_info.xml: 454 Chapter 22 Extending Android Application Reach <?xml version=""1.0"" encoding=""utf-8""?> <appwidget-provider xmlns:android=""http://schemas.android.com/apk/res/android"" android:minWidth=""146dp"" android:minHeight=""72dp"" android:updatePeriodMillis=""28800000"" android:initialLayout=""@layout/widget""> </appwidget-provider> This simple App Widget definition is encapsulated within the <appwidget-provider> XML tag.The minWidth and minHeight attributes dictate the size of the App Widget (a dimension, here in dp), and the updatePeriodMillis attribute is used to define how often the App Widget content is refreshed (using the App Widget update service)—in this case, once every eight hours. Finally, the App Widget layout definition is referenced using the initialLayout attribute—we talk more about this layout file in a few moments. An App Widget cannot be updated more frequently than every 30 minutes (1,800,000 mil- liseconds). Ensure that the updatePeriodMillis attribute of your App Widget provider reflects this limitation. This limit has testing implications. You might consider a tool to force an update or some sort of refresh button that users might benefit from, as well.If your widget must break this limit, which you should only do for a very good reason, you must implement the timer yourself. Keep in mind the effect on battery life and performance this decision might have. guidelines.The Home screen is divided into cells of a particular size.When the user attempts to install an App Widget, the system checks to make sure there is enough space (as dictated by the minimum width and height values of the App Widget). The basic formula for determining the size of your App Widget is to multiply the number of cells you want by 74, and then subtract two. In our case, we want an App Widget two cells high and two cells wide. Therefore, we use a size of ((74*2)-2) or 146. For a nice write-up on App Widget design guidelines, see the Android website: http://developer.android.com/ guide/practices/ui_guidelines/widget_design.html.There are a number of other attributes available within the <appwidget-provider> tag. using the configure attribute, which is especially useful when you support multiple simultaneous App Widget instances (see the App Widget write-ups on our book blog for more advanced App Widget implementations). For a complete list of available App Widget provider configuration details, see the class documentation for the android.appwidget.AppWidgetProviderInfo class. 455 Determining if the App Widget Requires a Configuration Activity Generally speaking, if there is more than one instance of an App Widget, each instance should look or behave differently.This isn’t a strict requirement; if each instance of the App Widget looks and acts the same, users quickly catch on and only install one instance at a time."
8,"Explain why if an App Widget refresh requires any lengthy blocking operations, it must use a service so that it can create a thread to perform these operations in the background","That is, a user can add any number of App Widgets of a particular kind to a host. It’s up to you, though, how they will differ. During the update event, each identifier must be iterated over and update each of the RemoteViews objects individually (that is, if you support different instances simultaneously). executed from the UI thread of the host process.When the updates are done, there is no guarantee that the App Widget Provider object stays around Hence,if an App Widget refresh requires any lengthy blocking operations, it must use a service so that it can create a thread to perform these operations in the background.","In order to load a layout resource (such as widget.xml defined earlier) into a RemoteViews object, you can use the following code: RemoteViews remoteView = new RemoteViews(context.getPackageName(), R.layout.widget); When you want to update the text in that layout’s TextView control, you need to use the setTextViewText() method of the RemoteViews class, like this: remoteView.setTextViewText(R.id.widget_text_threat, “Red alert!""); If you want the user to be able to click within the RelativeLayout control of the App Widget display and to launch the underlying application, use the setOnClickPendingIntent() method of the RemoteViews class. For example, the follow- ing code creates a pending intent that can launch the SimpleAppWidgetActivity activity: Intent launchAppIntent = new Intent(context, SimpleAppWidgetActivity.class); PendingIntent launchAppPendingIntent = PendingIntent.getActivity( context, 0, launchAppIntent, PendingIntent.FLAG_UPDATE_CURRENT); remoteView.setOnClickPendingIntent (R.id.widget_view, launchAppPendingIntent); Finally, when the RemoteViews object is all set up, the App Widget provider needs to tell the App Widget Manager about the updated RemoteViews object: ComponentName simpleWidget = new ComponentName(context, SimpleAppWidgetProvider.class); AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context); appWidgetManager.updateAppWidget(simpleWidget, remoteView); To update the appropriate App Widget, the AppWidgetManager object requires its compo- nent name.The App Widget Manager will then update the content of the specific named App Widget using the contents of the RemoteViews object you provide in the updateAppWidget() method. Each time the RemoteViews object is updated, it is rebuilt. Unfortunately, the complete implementation of the AppWidgetProvider class provided in SimpleAppWidget is too lengthy for print. See the SimpleAppWidgetProvider class within that sample project for the full details of how the threat level App Widget works. Chapter 22 Extending Android Application Reach Updating an App Widget When the onUpdate() method of the App Widget provider is called, a list of identifiers are passed in. Each identifier references a particular App Widget instance for this provider.That is, a user can add any number of App Widgets of a particular kind to a host. It’s up to you, though, how they will differ. During the update event, each identifier must be iterated over and update each of the RemoteViews objects individually (that is, if you support different instances simultaneously). executed from the UI thread of the host process.When the updates are done, there is no guarantee that the App Widget Provider object stays around.Therefore, if an App Widget refresh requires any lengthy blocking operations, it must use a service so that it can create a thread to perform these operations in the background.In our threat level App Widget example, we already have a service that performs some network operations in order to download updated threat level data.This service is perfect for the needs of an App Widget as well as the application, so they can share this service. Creating a App Widget Update Service Most App Widgets do not contain static content, but are updated from time to time. Normally, an Android service is used to enable App Widget content updates.The service performs any necessary update-related tasks, including spawning threads, connecting to the Internet, and so on.The App Widget provider’s onUpdate() method, which is called at the App Widget update interval, is a great place to start this update service. After the service has done its job, it should shut itself down until the next time fresh content is needed. n The SimpleDataUpdateService class runs at the App Widget update interval (started in the onUpdate() method of the App Widget provider).The service con- nects to the Internet, checks the current threat level, and stores the result in the application’s shared preferences. Finally, the service shuts itself down. It might be helpful to consider the application as the “owner” of this service—it provides information for both the application and the App Widget by saving data to the shared preferences. The PrefListenerService class listens for changes in the application’s shared pref- erences. In addition to using the onUpdate() method, this service is started when the App Widget is enabled, thus allowing it to be updated whenever the data changes (for example, when the underlying application modifies the shared prefer- ence by checking the threat level itself).When the threat level preference changes, this service triggers a call to the updateAppWidget() method of the App Widget provider, which updates the RemoteViews object for the App Widget—bypassing the frequency limitations of the App Widget Manager. It might be helpful to con- sider the App Widget as the “owner” of this service—it runs within the App Widget lifecycle and exists only to update the content of the App Widget. 459 Certainly, there are simpler ways to update your App Widget. For example, the App Widget could use its one service to do all the work of downloading the threat level data and updating the App Widget content, but then the application is left to do its own thing.The method described here illustrates how you can bypass some of the update frequency limitations of App Widgets and still share content between App Widgets and their underlying application. Updating the RemoteViews object need not happen from within the App Widget provider. It can be called directly from the application, too. In this example, the service created for downloading the threat level data is used by the application and App Widget alike. Using a service for downloading online data is a good practice for a number of reasons. However, if there was no download service to leverage, we could have gotten away with just one service."
9,Explain why the application’s content provider interface needs to be updated to handle queries to fill the live folder with data,"Finally, the base Intent object for each live folder item is set. In this case, the base intent has an action type of VIEW, as you might expect, and therefore is compatible with the content type handler technique. For more information on the configuration details that can be applied to a live folder, see the Android SDK documentation for the android.provider.LiveFolders package. Each time the user opens the live folder, the system performs a content provider query. Hence,the application’s content provider interface needs to be updated to handle queries to fill the live folder with data.","Several extras are set to provide the live folder instance with a label and icon, as well as specify the display mode of the live folder. Live folders have several canned display modes:The DISPLAY_MODE_LIST value causes all live folder content to display in ListView control (ideal for text content) and the DISPLAY_MODE_GRID displays live folder content in a GridView control—more appropriate if the live folder contents are graphics.Finally, the base Intent object for each live folder item is set. In this case, the base intent has an action type of VIEW, as you might expect, and therefore is compatible with the content type handler technique. For more information on the configuration details that can be applied to a live folder, see the Android SDK documentation for the android.provider.LiveFolders package. Each time the user opens the live folder, the system performs a content provider query.Therefore, the application’s content provider interface needs to be updated to handle queries to fill the live folder with data. As with search suggestions, you need to define a projection in order to map the content provider data columns to those that the live folder expects to use to fill the list or grid (depending on the display mode) within the folder. 483 For example, the following code defines a project to map the field notes’ unique identifiers and titles to the ID and name fields for the live folder items: private static final HashMap<String, String> FIELDNOTES_LIVE_FOLDER_PROJECTION_MAP; static { FIELDNOTES_LIVE_FOLDER_PROJECTION_MAP = new HashMap<String, String>(); FIELDNOTES_LIVE_FOLDER_PROJECTION_MAP .put(LiveFolders._ID, _ID + “ AS “ + LiveFolders._ID); FIELDNOTES_LIVE_FOLDER_PROJECTION_MAP.put( LiveFolders.NAME, FIELDNOTES_TITLE + “ AS “ + LiveFolders.NAME); } Whenever the live folder is opened by the user, the system executes a query on the Uri provided as part of the live folder configuration. Don’t forget to define the live Uri address and register it in the content provider’s UriMatcher object (using the addURI() method). content:// com.androidbook.simplelivefolder. By providing a special live folder Uri for the content provider queries, you can simply update the content provider’s query method to handle the specialized query, including building the projection, performing the appropriate query, and returning the results for display in the live folder. Let’s take a closer look at the field notes content provider query() method: @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder(); queryBuilder.setTables(SimpleFieldnotesDatabase.FIELDNOTES_TABLE); int match = sURIMatcher.match(uri); switch (match) { case FIELDNOTE_ITEM: String id = uri.getLastPathSegment(); queryBuilder.appendWhere(_ID + “="" + id); break; case FIELDNOTES_LIVE: queryBuilder.setProjectionMap( FIELDNOTES_LIVE_FOLDER_PROJECTION_MAP); break; default: throw new IllegalArgumentException(“Invalid URI: “ + uri); } SQLiteDatabase sql = database.getReadableDatabase(); Cursor cursor = queryBuilder.query(sql, 484 Chapter 22 Extending Android Application Reach projection, selection, selectionArgs, null, null, sortOrder); cursor.setNotificationUri(getContext().getContentResolver(), uri); return cursor; } This query() method implementation handles both regular content queries and special live folder queries (those that come in with the live Uri).When the live folder query occurs, we simply use the handy setProjectionMap() method of the QueryBuilder object to set and execute the query as normal. Finally, the live folder Activity class needs to be registered within the application Android manifest file with an intent filter with the CREATE_LIVE_FOLDER action. For example, here is an excerpt from the field notes Android manifest file that does just that: <activity android:name=""SimpleLiveFolderCreateActivity"" android:label=""@string/livefolder_label"" android:icon=""@drawable/foldericon""> <intent-filter> <action android:name=""android.intent.action.CREATE_LIVE_FOLDER"" /> <category android:name=""android.intent.category.DEFAULT"" /> </intent-filter> </activity> This type of Activity registration should look familiar.The SimpleLiveFolderCreateActivity class is responsible for handling the CREATE_LIVE_FOLDER intent (as dictated by the intent filter).You can also set the live folder’s text label and icon using the attributes for the creation activity. The icon and text label shown in the Live Folder picker is set separately from the icon and label shown for a given instance of a live folder. You can set the information for the Live Folder in the picker using the android:label and android:icon attributes of the <activity> tag corresponding to the activity that handles the intent filter for android.intent.action.CREATE_LIVE_FOLDER action in the Android manifest file. The icon and label for each Live Folder instance on the Home screen (or other live folder host) is set as part intent extra fields when your Activity class handles the action LiveFolders.ACTION_CREATE_LIVE_FOLDER. 485 Installing a Live Folder After the application is capable of handling the creation of a live folder, your development work is done. As a user, you can install a live folder on the Home screen using the following steps: 1. Long-press on an empty space in the Home Screen.2. From the menu, choose the Folders option, as shown in Figure 22.8 (left). Installing a live folder on the Home screen."
10,"Explain why an application might already support speech recognition, to some extent, without any changes","Speech services are best tested on a real Android device. We used an HTC Nexus One running Android 2.2 in our testing. You can enhance an application with speech recognition support by using the speech recognition framework provided within the Android SDK. Speech recognition involves speaking into the device microphone and enabling the software to detect and interpret 504 Chapter 24 Handling Advanced User Input that speech and translate it into a string. Speech recognition services are intended for use with short command-like phrases without pauses, not for long dictation. If you want more robust speech recognition, you need to implement your own solution.On Android SDK 2.1 and higher, access to speech recognition is built in to most pop- up keyboards Hence,an application might already support speech recognition, to some extent, without any changes.","Because speech recognition and Text-To-Speech applications are all the rage, and their technologies are often used for navigation applications (especially because many states are passing laws making driving while using a mobile device without hands-free operation illegal), let’s look at these two technologies in a little more detail. achieved using speech recognition services and speech output can be achieved using TextTo-Speech services. Not all devices support these services. However, certain types of applications—most notably hands-free applications such as directional navigation—often benefit from the use of these types of input. device; some services might require a network connection to function properly. Many of the code examples provided in this section are taken from the SimpleSpeech application. The source code for this application is provided for download on the book website.Speech services are best tested on a real Android device. We used an HTC Nexus One running Android 2.2 in our testing. You can enhance an application with speech recognition support by using the speech recognition framework provided within the Android SDK. Speech recognition involves speaking into the device microphone and enabling the software to detect and interpret 504 Chapter 24 Handling Advanced User Input that speech and translate it into a string. Speech recognition services are intended for use with short command-like phrases without pauses, not for long dictation. If you want more robust speech recognition, you need to implement your own solution.On Android SDK 2.1 and higher, access to speech recognition is built in to most pop- up keyboards.Therefore, an application might already support speech recognition, to some extent, without any changes. However, directly accessing the recognizer can allow for more interesting spoken-word control over applications. speech recorder.This launches the recorder (shown in Figure 24.3), allowing the user to record speech. Recording speech with the RecognizerIntent.The sound file is sent to an underlying recognition server for processing, so this feature is not really practical for devices that don’t have a reasonable network connection.You can then retrieve the results of the speech recognition processing and use them within your application. Note that you might receive multiple results for a given speech segment. Speech recognition technology is continually evolving and improving. Be sure to enunciate clearly when speaking to your device. Sometimes it might take several tries before the speech recognition engine interprets your speech correctly. using the RecognizerIntent intent: public class SimpleSpeechActivity extends Activity { private static final int VOICE_RECOGNITION_REQUEST = 1; Exploring the Accessibility Framework 505 @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); } public void recordSpeech(View view) { Intent intent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH); intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM); intent.putExtra(RecognizerIntent.EXTRA_PROMPT, “Please speak slowly and clearly""); startActivityForResult(intent, VOICE_RECOGNITION_REQUEST); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { if (requestCode == VOICE_RECOGNITION_REQUEST && resultCode == RESULT_OK) { ArrayList<String> matches = data.getStringArrayListExtra( RecognizerIntent.EXTRA_RESULTS); TextView textSaid = (TextView) findViewById(R.id.TextSaid); textSaid.setText(matches.get(0)); } super.onActivityResult(requestCode, resultCode, data); } } In this case, the intent is initiated through the click of a Button control, which causes the recordSpeech() method to be called.The RecognizerIntent is configured as follows: n The intent action is set to ACTION_RECOGNIZE_SPEECH in order to prompt the user to speak and send that sound file in for speech recognition. An intent extra called EXTRA_LANGUAGE_MODEL is set to LANGUAGE_MODEL_FREE_FORM to simply perform standard speech recognition.There is also another language model especially for web searches called LANGUAGE_MODEL_WEB_SEARCH. An intent extra called EXTRA_PROMPT is set to a string to display to the user during speech input. startActivityForResult() method, and then the result is captured in the onActivityResult() method.The resulting text is then displayed in the TextView con- trol called TextSaid. In this case, only the first result provided in the results is displayed to the user. So, for example, the user could press the button initiating the recordSpeech() 506 Chapter 24 Handling Advanced User Input method, say “We’re going to need a bigger boat,” and that text is then displayed in the application’s TextView control, as shown in Figure 24.4. The text string resulting from the RecognizerIntent. The Android platform includes a TTS engine (android.speech.tts) that enables devices to perform speech synthesis.You can use the TTS engine to have your applications “read” text to the user.You might have seen this feature used frequently with location-based services (LBS) applications that allow for hands-free directions. Other applications use this feature for users who have reading or sight problems.The synthesized speech can be played immediately or saved to an audio file, which can be treated like any other audio file. To provide TTS services to users, an Android device must have both the TTS engine (available in Android SDK 1.6 and higher) and the appropriate language resource files. In some cases, the user must install the appropriate language resource files (assuming that the user has space for them) from a remote location. The users can install the language resource files by going to Settings, Voice Input & Output Settings, Text-to-Speech, Install Voice Data."
11,Explain why you must return true in the onScaleBegin() method as it happens at the beginning of a scale-type gesture,"As before, the onScale() helper method of the GameAreaView applies some scaling to the bitmap graphic and then calls the invalidate() method, forcing the view to be redrawn. pret the scale gestures and call the GameAreaView methods we just implemented. Here’s the implementation of the GestureListener class: private class GestureListener implements ScaleGestureDetector.OnScaleGestureListener { GameAreaView view; public GestureListener(GameAreaView view) { this.view = view; } 518 Chapter 24 Handling Advanced User Input @Override public boolean onScale(ScaleGestureDetector detector) { float scale = detector.getScaleFactor(); view.onScale(scale); return true; } @Override public boolean onScaleBegin(ScaleGestureDetector detector) { return true; } @Override public void onScaleEnd(ScaleGestureDetector detector) { } } Remember that you must return true for any gesture or motion event that you Want to detect Hence,you must return true in the onScaleBegin() method as it happens at the beginning of a scale-type gesture.","In order to handle scale gestures, the GameAreaView class needs to include the appropriate gesture detector: a ScaleGestureDetector.The GameAreaView class needs to be wired up for scale gesture support in a similar fashion as when we implemented single touch gestures earlier, including initializing the gesture detector in the class constructor, overriding the onTouchEvent() method to pass the MotionEvent objects to the gesture detector, and overriding the onDraw() method to draw the view appropriately as necessary.We also need to update the GameAreaView class to keep track of the bitmap graphic size (using a Matrix) and provide a helper method for growing or shrinking the graphic. Here is the new implementation of the GameAreaView class with scale gesture support: public class GameAreaView extends View { private ScaleGestureDetector multiGestures; private Matrix scale; private Bitmap droid; public GameAreaView(Context context, int iGraphicResourceId) { super(context); scale = new Matrix(); Handling Common Single-Touch Gestures 517 GestureListener listener = new GestureListener(this); multiGestures = new ScaleGestureDetector(context, listener); droid = BitmapFactory.decodeResource(getResources(), iGraphicResourceId); } public void onScale(float factor) { scale.preScale(factor, factor); invalidate(); } @Override protected void onDraw(Canvas canvas) { Matrix transform = new Matrix(scale); float width = droid.getWidth() / 2; float height = droid.getHeight() / 2; transform.postTranslate(-width, -height); transform.postConcat(scale); transform.postTranslate(width, height); canvas.drawBitmap(droid, transform, null); } @Override public boolean onTouchEvent(MotionEvent event) { boolean retVal = false; retVal = multiGestures.onTouchEvent(event); return retVal; } } As you can see, the GameAreaView class keeps track of what size the bitmap should be at any time using the Matrix variable called scale.The onTouchEvent() method is used to capture motion events and pass them along to a ScaleGestureDetector gesture detector.As before, the onScale() helper method of the GameAreaView applies some scaling to the bitmap graphic and then calls the invalidate() method, forcing the view to be redrawn. pret the scale gestures and call the GameAreaView methods we just implemented. Here’s the implementation of the GestureListener class: private class GestureListener implements ScaleGestureDetector.OnScaleGestureListener { GameAreaView view; public GestureListener(GameAreaView view) { this.view = view; } 518 Chapter 24 Handling Advanced User Input @Override public boolean onScale(ScaleGestureDetector detector) { float scale = detector.getScaleFactor(); view.onScale(scale); return true; } @Override public boolean onScaleBegin(ScaleGestureDetector detector) { return true; } @Override public void onScaleEnd(ScaleGestureDetector detector) { } } Remember that you must return true for any gesture or motion event that you Want to detect.Therefore, you must return true in the onScaleBegin() method as it happens at the beginning of a scale-type gesture. Most of the implementation of the GestureListener methods involves our interpretation of the data for the scale gesture. Specifically, we use the scale factor (provided by the getScaleFactor() method) to calculate whether we should shrink or grow the bitmap graphic, and by how much.We pass this information to the onScale() helper method we just implemented in the GameAreaView class.Now, if you were to use the GameAreaView class within your application, scale gestures might look something like Figure 24.6. The Android emulator does not currently support multi-touch input. You will have to run and test multi-touch support such as the scale gesture using a device running Android 2.2 or higher. Gestures can enhance your Android application user interfaces in new, interesting, and intuitive ways. Closely mapping the operations being performed on the screen to the user’s finger motion makes a gesture feel natural and intuitive. Making application operations look natural requires some experimentation on the part of the developer. Keep in mind that devices vary in processing power, and this might be a factor in making things seem natural. 519 Figure 24.6 Scale up (left) and scale down (right) gestures. Some Android devices have hardware trackballs, but not all. Developers can handle trackball events within a View control in a similar fashion to click events or gestures.To handle trackball events, you can leverage the View class method called onTrackballEvent().This method, like a gesture, has a single parameter: a MotionEvent object.You can use the getX() and getY() methods of the MotionEvent class to determine the relative move- ment of the trackball. Optical track-pads such as those available on the Droid Incredible can be supported in the same way. If your application requires the device to have a trackball, you should set the <uses-configuration> tag to specify that a trackball is required within your application’s Android manifest file. Many Android devices on the market today have landscape and portrait modes and can seamlessly transition between these orientations.The Android operating system automatically handles these changes for your application, if you so choose.You can also provide alternative resources, such as different layouts, for portrait and landscape modes (more on 520 Chapter 24 Handling Advanced User Input this in Chapter 25,“Targeting Different Device Configurations and Languages”). Also, you can directly access device sensors such as the accelerometer, as we talked about in Chapter 19,“Using Android’s Optional Hardware APIs,” to capture device orientation along three axes."
12,Explain why the following line of code enabled a simple vibration pattern that occurs whenever the notification is triggered: notify,"Without this permission, the vibrate functionality will not work nor will there be any error.With this permission enabled, the application is free to vibrate the phone however it wants.This is accomplished by describing the vibrate member variable, which determines the vibration pattern. An array of long values describes the vibration duration. Hence,the following line of code enabled a simple vibration pattern that occurs whenever the notification is triggered: notify.","When the notification identifiers match, the old notification is updated.When a notification with matching identifier is posted, the ticker text does not draw a second time.To show the user that something has changed, you can use a counter.The value of the number member variable of the Notification object tracks and displays this. For instance, we can set it to the number 4, as shown here: notify.number = 4; This is displayed to the user as a small number over the icon.This is only displayed in the status bar and not in the expanded status bar, although an application could update the 428 Chapter 20 Working with Notifications text to also display this information. Figure 20.3 shows what this might look like in the status bar. Status bar notification with the count of “4” showing over the icon. When a user clicks on the notification, the Intent assigned is triggered. At some point after this, the application might want to clear the notification from the system notifications queue.This is done through a call to the cancel() method of the NotificationManager object. For instance, the notification we created earlier could be canceled with the following call: notifier.cancel(NOTIFY_1); This cancels the notification that has the same identifier. However, if the application doesn’t care what the user does after clicking on the notification, there is an easier way to cancel notifications. Simply set a flag to do so, as shown here: notify.flags |= Notification.FLAG_AUTO_CANCEL; Setting the Notification.FLAG_AUTO_CANCEL flag causes notifications to be canceled when the user clicks on them.This is convenient and easy for the application when just launching the Intent is good enough. have encountered. Most of the interaction with it is through direct access to its public Vibrating the Phone 429 variables instead of through helper methods.This is useful for a background application or service, discussed in Chapter 21,“Working with Services.”The Notification object can be kept around and only the values that need to be changed can be modified. After any change, the Notification needs to be posted again by calling the notify() method. Vibration is a great way to enable notifications to catch the attention of a user in noisy environments or alert the user when visible and audible alerts are not appropriate (though a vibrating phone is often noisy on a hard desktop surface). Android notifications give a fine level of control over how vibration is performed. However, before the application can use vibration with a notification, an explicit permission is needed.The following XML within your application’s AndroidManifest.xml file is required to use vibration: <uses-permission android:name=""android.permission.VIBRATE"" /> Warning The vibrate feature must be tested on the handset. The emulator does not indicate vibration in any way. Also, some Android devices do not support vibration.Without this permission, the vibrate functionality will not work nor will there be any error.With this permission enabled, the application is free to vibrate the phone however it wants.This is accomplished by describing the vibrate member variable, which determines the vibration pattern. An array of long values describes the vibration duration.Thus, the following line of code enabled a simple vibration pattern that occurs whenever the notification is triggered: notify.vibrate = new long[] {0, 200, 200, 600, 600}; This vibration pattern vibrates for 200 milliseconds and then stops vibrating for 200 milliseconds. After that, it vibrates for 600 milliseconds and then stops for that long.To repeat the Notification alert, a notification flag can be set so it doesn’t stop until the user clears the notification. An application can use different patterns of vibrations to alert the user to different types of events or even present counts. For instance, think about a grandfather clock with which you can deduce the time based on the tones that are played. Using short, unique patterns of vibration can be useful, and users become accustomed to them. Chapter 20 Working with Notifications Blinking the Lights Blinking lights are a great way to pass information silently to the user when other forms of alert are not appropriate.The Android SDK provides reasonable control over a multicolored indicator light, when such a light is available on the device. Users might recognize this light as a service indicator or battery level warning. An application can take advantage of this light as well, by changing the blinking rate or color of the light. Indicator lights are not available on all Android devices. Also, the emulator does not display the light’s state. This mandates testing on actual hardware.You must set a flag on the Notification object to use the indicator light.Then, the color of the light must be set and information about how it should blink.The following block of code configures the indicator light to shine green and blink at rate of 1 second on and 1 second off: notify.flags |= Notification.FLAG_SHOW_LIGHTS; notify.ledARGB = Color.GREEN; notify.ledOnMS = 1000; notify.ledOffMS = 1000; Although you can set arbitrary color values, a typical physical implementation of the indicator light has three small LEDs in red, green, and blue. Although the colors blend reasonably well, they won’t be as accurate as the colors on the screen. For instance, on the T-Mobile G1, the color white looks a tad pink. On some devices, certain notifications appear to take precedence when it comes to using the indicator light. For instance, the light on the T-Mobile G1 is always solid green when plugged in to a USB port, regardless of other applications are trying to use the indicator light. Additionally, on the Nexus One, the color trackball is not lit unless the screen is off."
